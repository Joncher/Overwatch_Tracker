{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _ReactMove = require('./ReactMove');\n\nvar _Context = require('../utils/Context');\n\nvar _Selectors = require('../utils/Selectors');\n\nvar _Selectors2 = _interopRequireDefault(_Selectors);\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n\n\nvar getLineBackgroundColor = function getLineBackgroundColor(dark) {\n  return dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)';\n};\n\nvar getBackgroundColor = function getBackgroundColor(dark) {\n  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';\n};\n\nvar Cursor = function (_React$PureComponent) {\n  _inherits(Cursor, _React$PureComponent);\n\n  function Cursor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Cursor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call.apply(_ref, [this].concat(args))), _this), _this.prevValue = null, _this.updateCursor = function () {\n      var _this$props = _this.props,\n          primary = _this$props.primary,\n          snap = _this$props.snap,\n          axisID = _this$props.axisID,\n          onChange = _this$props.onChange,\n          cursor = _this$props.cursor,\n          stackData = _this$props.stackData,\n          primaryAxes = _this$props.primaryAxes,\n          secondaryAxes = _this$props.secondaryAxes,\n          pointer = _this$props.pointer,\n          hovered = _this$props.hovered,\n          gridWidth = _this$props.gridWidth,\n          gridHeight = _this$props.gridHeight,\n          dispatch = _this$props.dispatch; // Don't render until we have all dependencies\n\n      if (!stackData || !primaryAxes.length || !secondaryAxes.length) {\n        return null;\n      }\n\n      var resolvedCursor = cursor || {\n        value: null\n      };\n      var _resolvedCursor$value = resolvedCursor.value,\n          value = _resolvedCursor$value === undefined ? null : _resolvedCursor$value,\n          datum = resolvedCursor.datum;\n      var x = void 0;\n      var y = void 0;\n      var show = false;\n      var resolvedAxisID = axisID || datum && datum.series && datum.series[(primary ? 'primary' : 'secondary') + 'AxisID']; // Determine the axis to use\n\n      var axis = _Utils2.default.getAxisByAxisID(primary ? primaryAxes : secondaryAxes, resolvedAxisID);\n\n      var siblingAxis = primary ? secondaryAxes[0] : primaryAxes[0]; // Resolve the invert function\n\n      var invert = axis.scale.invert || function (d) {\n        return d;\n      }; // If the cursor isn't in the grid, don't display\n\n\n      if (pointer.active) {\n        // Default to cursor x and y\n        show = true;\n\n        if (pointer.x < -1 || pointer.x > gridWidth + 1 || pointer.y < -1 || pointer.y > gridHeight + 1) {\n          show = false;\n        } // Implement snapping\n\n\n        if (axis.type === 'ordinal' || snap) {\n          // For snapping we need the hovered datums\n          if (!hovered || !hovered.datums || !hovered.datums.length) {\n            return;\n          }\n\n          datum = _Utils2.default.getClosestPoint(pointer, hovered.datums);\n\n          if (axis.vertical) {\n            value = datum.yValue;\n          } else {\n            value = datum.xValue;\n          }\n        } else if (axis.vertical) {\n          value = invert(y);\n        } else {\n          value = invert(x);\n        }\n      } else {\n        show = false;\n        datum = {};\n      }\n\n      var newCursor = {\n        axis: axis,\n        siblingAxis: siblingAxis,\n        value: show ? value : null,\n        datum: datum\n      };\n\n      if ((resolvedCursor && resolvedCursor.value) !== newCursor.value) {\n        onChange(newCursor);\n      }\n\n      dispatch(function (state) {\n        return _extends({}, state, {\n          cursors: _extends({}, state.cursors, _defineProperty({}, primary ? 'primary' : 'secondary', newCursor))\n        });\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Cursor, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.updateCursor();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prev) {\n      if (_Utils2.default.shallowCompare(prev, this.props, ['pointer', 'hovered', 'stackData', 'primaryAxes', 'secondaryAxes'])) {\n        this.updateCursor();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          showLine = _props.showLine,\n          showLabel = _props.showLabel,\n          manualValue = _props.value,\n          primary = _props.primary,\n          snap = _props.snap,\n          cursor = _props.cursor,\n          _props$offset = _props.offset,\n          left = _props$offset.left,\n          top = _props$offset.top,\n          gridX = _props.gridX,\n          gridY = _props.gridY,\n          gridWidth = _props.gridWidth,\n          gridHeight = _props.gridHeight,\n          dark = _props.dark,\n          render = _props.render,\n          children = _props.children,\n          Comp = _props.Component;\n\n      if (!cursor) {\n        return null;\n      }\n\n      var axis = cursor.axis,\n          siblingAxis = cursor.siblingAxis,\n          value = cursor.value,\n          datum = cursor.datum; // Is the value manually set via the value prop?\n\n      var isManual = typeof manualValue !== 'undefined'; // Resolve the value from manual or the cursor info\n\n      var resolvedValue = isManual ? manualValue : value; // Should we animate?\n\n      var animated = snap || axis.type === 'ordinal'; // Get the sibling range\n\n      var siblingRange = siblingAxis.scale.range(); // Set the opacity\n\n      var opacity = _Utils2.default.isValidPoint(resolvedValue) ? 1 : 0; // Fall back to the last value for coordinates\n\n      resolvedValue = _Utils2.default.isValidPoint(resolvedValue) ? resolvedValue : this.prevValue; // Store the latest valid resolvedValue\n\n      if (_Utils2.default.isValidPoint(resolvedValue)) {\n        this.prevValue = resolvedValue;\n      }\n\n      var x = void 0;\n      var y = void 0;\n      var x1 = void 0;\n      var x2 = void 0;\n      var y1 = void 0;\n      var y2 = void 0;\n      var alignPctX = void 0;\n      var alignPctY = void 0; // Vertical alignment\n\n      if (axis.vertical) {\n        y = axis.scale(resolvedValue);\n        x1 = siblingRange[0];\n        x2 = siblingRange[1];\n        y1 = y - 1;\n        y2 = y + axis.cursorSize + 1;\n\n        if (axis.position === 'left') {\n          alignPctX = -100;\n          alignPctY = -50;\n        } else {\n          alignPctX = 0;\n          alignPctY = -50;\n        }\n      } else {\n        x = axis.scale(resolvedValue);\n        x1 = x - 1;\n        x2 = x + axis.cursorSize + 1;\n        y1 = siblingRange[0];\n        y2 = siblingRange[1];\n\n        if (axis.position === 'top') {\n          alignPctX = -500;\n          alignPctY = -100;\n        } else {\n          alignPctX = -50;\n          alignPctY = 0;\n        }\n      } // If the cursor isn't in the grid, don't display\n\n\n      if (x < -1 || x > gridWidth + 1 || y < -1 || y > gridHeight + 1) {\n        opacity = 0;\n      }\n\n      var renderProps = {\n        axis: axis,\n        datum: datum,\n        value: resolvedValue,\n        primary: primary\n      };\n      renderProps.formattedValue = axis.vertical ? typeof value !== 'undefined' ? axis.format(axis.stacked && !primary ? datum.totalValue : value) : '' : typeof value !== 'undefined' ? axis.format(axis.stacked && !primary ? datum.totalValue : value) : '';\n      var lineStartX = Math.min(x1, x2);\n      var lineStartY = Math.min(y1, y2);\n      var lineEndX = Math.max(x1, x2);\n      var lineEndY = Math.max(y1, y2);\n      var bubbleX = axis.vertical && axis.RTL ? lineEndX : x1 + (!axis.vertical ? (x2 - x1) / 2 : 0) + (!axis.vertical ? 1 : 0);\n      var bubbleY = !axis.vertical && axis.RTL ? lineStartY : y1 + (axis.vertical ? (y2 - y1) / 2 : 0) + (axis.vertical ? 1 : 0);\n      var lineHeight = Math.max(lineEndY - lineStartY, 0);\n      var lineWidth = Math.max(lineEndX - lineStartX, 0);\n      var start = {\n        transform: 'translate3d(' + (left + gridX) + 'px, ' + (top + gridY) + 'px, 0)',\n        opacity: 0\n      };\n      var update = {\n        transform: 'translate3d(' + (left + gridX) + 'px, ' + (top + gridY) + 'px, 0)',\n        opacity: opacity\n      };\n      var renderedChildren = void 0;\n\n      if (Comp) {\n        renderedChildren = _react2.default.createElement(Comp, null, renderProps);\n      } else {\n        renderedChildren = (render || children)(renderProps);\n      }\n\n      return _react2.default.createElement(_ReactMove.Animate, {\n        show: !!opacity,\n        start: start,\n        enter: update,\n        update: update,\n        leave: update,\n        style: {\n          pointerEvents: 'none',\n          position: 'absolute',\n          top: 0,\n          left: 0\n        },\n        className: 'Cursor'\n      }, showLine ? _react2.default.createElement('div', {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          transform: 'translate3d(' + lineStartX + 'px, ' + lineStartY + 'px, 0px)',\n          width: lineWidth + 'px',\n          height: lineHeight + 'px',\n          background: getLineBackgroundColor(dark),\n          WebkitBackfaceVisibility: 'hidden',\n          transition: animated ? '.2s all ease-out' : 'none'\n        }\n      }) : null, showLabel ? _react2.default.createElement('div', {\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          transform: 'translate3d(' + bubbleX + 'px, ' + bubbleY + 'px, 0px)',\n          transition: animated ? '.2s all ease-out' : 'none'\n        }\n      }, _react2.default.createElement('div', {\n        style: {\n          padding: '5px',\n          fontSize: '10px',\n          background: getBackgroundColor(dark),\n          color: dark ? 'black' : 'white',\n          borderRadius: '3px',\n          position: 'relative',\n          transform: 'translate3d(' + alignPctX + '%, ' + alignPctY + '%, 0px)',\n          whiteSpace: 'nowrap'\n        }\n      }, renderedChildren)) : null);\n    }\n  }]);\n\n  return Cursor;\n}(_react2.default.PureComponent);\n\nCursor.defaultProps = {\n  children: function children(_ref2) {\n    var axis = _ref2.axis,\n        value = _ref2.value,\n        formattedValue = _ref2.formattedValue,\n        datum = _ref2.datum,\n        primary = _ref2.primary;\n    return _react2.default.createElement('span', null, formattedValue);\n  },\n  snap: true,\n  showLine: true,\n  showLabel: true,\n  axisID: undefined,\n  onChange: function onChange() {}\n};\nCursor.isHtml = true;\nexports.default = (0, _Context.PointerConnect)(function (state) {\n  return {\n    pointer: state.pointer\n  };\n})((0, _Context.ChartConnect)(function () {\n  var selectors = {\n    primaryAxes: _Selectors2.default.primaryAxes(),\n    secondaryAxes: _Selectors2.default.secondaryAxes(),\n    offset: _Selectors2.default.offset(),\n    gridHeight: _Selectors2.default.gridHeight(),\n    gridWidth: _Selectors2.default.gridWidth(),\n    gridX: _Selectors2.default.gridX(),\n    gridY: _Selectors2.default.gridY()\n  };\n  return function (state, props) {\n    return {\n      stackData: state.stackData,\n      cursor: state.cursors[props.primary ? 'primary' : 'secondary'],\n      hovered: state.hovered,\n      primaryAxes: selectors.primaryAxes(state),\n      secondaryAxes: selectors.secondaryAxes(state),\n      offset: selectors.offset(state),\n      gridHeight: selectors.gridHeight(state),\n      gridWidth: selectors.gridWidth(state),\n      gridX: selectors.gridX(state),\n      gridY: selectors.gridY(state),\n      dark: state.dark\n    };\n  };\n})(Cursor));","map":null,"metadata":{},"sourceType":"script"}