{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nexports.default = {\n  requestAnimationFrame: _raf2.default,\n  throttle: throttle,\n  getStatus: getStatus,\n  getStatusStyle: getStatusStyle,\n  getMultiFocus: getMultiFocus,\n  getClosestPoint: getClosestPoint,\n  normalizeComponent: normalizeComponent,\n  materializeStyles: materializeStyles,\n  normalizeGetter: normalizeGetter,\n  normalizePathGetter: normalizePathGetter,\n  isArray: isArray,\n  isValidPoint: isValidPoint,\n  getAxisByAxisID: getAxisByAxisID,\n  getAxisIndexByAxisID: getAxisIndexByAxisID,\n  shallowCompare: shallowCompare\n};\n\nfunction throttle(func) {\n  var running = void 0;\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (running) return;\n    running = (0, _raf2.default)(function () {\n      func.apply(undefined, args);\n      running = false;\n    });\n  };\n}\n\nfunction getStatus(item, hovered, selected) {\n  var status = {\n    selected: false,\n    hovered: false,\n    otherSelected: false,\n    otherHovered: false\n  };\n\n  if (item.series) {\n    var d = void 0;\n\n    if (selected && selected.active && selected.datums) {\n      for (var i = 0; i < selected.datums.length; i++) {\n        d = selected.datums[i];\n\n        if (d.seriesID === item.series.id && d.index === item.index) {\n          status.selected = true;\n          break;\n        }\n      }\n\n      status.otherSelected = !status.selected;\n    }\n\n    if (hovered && hovered.active && hovered.datums) {\n      for (var _i = 0; _i < hovered.datums.length; _i++) {\n        d = hovered.datums[_i];\n\n        if (d.seriesID === item.series.id && d.index === item.index) {\n          status.hovered = true;\n          break;\n        }\n      }\n\n      status.otherHovered = !status.hovered;\n    }\n  } else {\n    if (selected && selected.active && selected.series) {\n      status.selected = selected.series.id === item.id;\n      status.otherSelected = !status.selected;\n    }\n\n    if (hovered && hovered.active && hovered.series) {\n      status.hovered = hovered.series.id === item.id;\n      status.otherHovered = !status.hovered;\n    }\n  }\n\n  return status;\n}\n\nfunction getStatusStyle(item, status, decorator, defaults) {\n  if (item.series) {\n    defaults = _extends({}, defaults, item.series.style);\n  }\n\n  return materializeStyles(decorator(_extends({}, item, status)), defaults);\n}\n\nfunction getMultiFocus(_ref) {\n  var focus = _ref.focus,\n      points = _ref.points,\n      gridX = _ref.gridX,\n      gridY = _ref.gridY,\n      gridWidth = _ref.gridWidth,\n      gridHeight = _ref.gridHeight,\n      width = _ref.width,\n      height = _ref.height;\n\n  var invalid = function invalid() {\n    throw new Error(JSON.stringify(focus) + ' is not a valid tooltip focus option. You should use a single focus option or 2 non-conflicting focus options.');\n  };\n\n  var x = void 0;\n  var y = void 0;\n  var xMin = points[0].focus.x;\n  var xMax = points[0].focus.x;\n  var yMin = points[0].focus.y;\n  var yMax = points[0].focus.y;\n  points.forEach(function (point) {\n    xMin = Math.min(point.focus.x, xMin);\n    xMax = Math.max(point.focus.x, xMax);\n    yMin = Math.min(point.focus.y, yMin);\n    yMax = Math.max(point.focus.y, yMax);\n  });\n\n  if (focus.length > 2) {\n    return invalid();\n  }\n\n  focus = focus.sort(function (a) {\n    return a.includes('center') || a.includes('Center') ? 1 : -1;\n  });\n\n  for (var i = 0; i < focus.length; i++) {\n    var focusPart = focus[i]; // Horizontal Positioning\n\n    if (['left', 'right', 'gridLeft', 'gridRight', 'chartLeft', 'chartRight'].includes(focusPart)) {\n      if (typeof x !== 'undefined') {\n        invalid();\n      }\n\n      if (focusPart === 'left') {\n        x = xMin;\n      } else if (focusPart === 'right') {\n        x = xMax;\n      } else if (focusPart === 'gridLeft') {\n        x = gridX;\n      } else if (focusPart === 'gridRight') {\n        x = gridX + gridWidth;\n      } else if (focusPart === 'chartLeft') {\n        x = 0;\n      } else if (focusPart === 'chartRight') {\n        x = width;\n      } else {\n        invalid();\n      }\n    } // Vertical Positioning\n\n\n    if (['top', 'bottom', 'gridTop', 'gridBottom', 'chartTop', 'chartBottom'].includes(focusPart)) {\n      if (typeof y !== 'undefined') {\n        invalid();\n      }\n\n      if (focusPart === 'top') {\n        y = yMin;\n      } else if (focusPart === 'bottom') {\n        y = yMax;\n      } else if (focusPart === 'gridTop') {\n        y = gridY;\n      } else if (focusPart === 'gridBottom') {\n        y = gridY + gridHeight;\n      } else if (focusPart === 'chartTop') {\n        y = 0;\n      } else if (focusPart === 'chartBottom') {\n        y = height;\n      } else {\n        invalid();\n      }\n    } // Center Positioning\n\n\n    if (['center', 'gridCenter', 'chartCenter'].includes(focusPart)) {\n      if (focusPart === 'center') {\n        if (typeof y === 'undefined') {\n          y = (yMin + yMax) / 2;\n        }\n\n        if (typeof x === 'undefined') {\n          x = (xMin + xMax) / 2;\n        }\n      } else if (focusPart === 'gridCenter') {\n        if (typeof y === 'undefined') {\n          y = gridY + gridHeight / 2;\n        }\n\n        if (typeof x === 'undefined') {\n          x = gridX + gridWidth / 2;\n        }\n      } else if (focusPart === 'chartCenter') {\n        if (typeof y === 'undefined') {\n          y = height / 2;\n        }\n\n        if (typeof x === 'undefined') {\n          x = width / 2;\n        }\n      } else {\n        invalid();\n      }\n    } // Auto center the remainder if there is only one focusPart listed\n\n\n    if (focus.length === 1) {\n      if (focus[0].includes('grid')) {\n        focus.push('gridCenter');\n      } else if (focus[0].includes('chart')) {\n        focus.push('chartCenter');\n      } else {\n        focus.push('center');\n      }\n    }\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction getClosestPoint(position, datums) {\n  if (!datums || !position || !datums.length) {\n    return;\n  }\n\n  var closestDistance = Infinity;\n  var closestDatum = datums[0];\n  datums.forEach(function (datum) {\n    datum.pointerPoints.forEach(function (pointerPoint) {\n      var distance = Math.sqrt(Math.pow(pointerPoint.x - position.x, 2) + Math.pow(pointerPoint.y - position.y, 2));\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestDatum = datum;\n      }\n    });\n  });\n  return closestDatum;\n}\n\nfunction normalizeComponent(Comp) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Comp;\n  return typeof Comp === 'function' ? Object.getPrototypeOf(Comp).isReactComponent ? _react2.default.createElement(Comp, params) : Comp(params) : fallback;\n}\n\nfunction normalizeColor(style, defaults) {\n  return _extends({}, style, {\n    stroke: style.stroke || style.color || defaults.stroke || defaults.color,\n    fill: style.fill || style.color || defaults.fill || defaults.color\n  });\n}\n\nfunction materializeStyles() {\n  var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  style = normalizeColor(style, defaults);\n  ['area', 'line', 'rectangle', 'circle'].forEach(function (type) {\n    style[type] = style[type] ? materializeStyles(style[type], defaults) : {};\n  });\n  return style;\n}\n\nfunction normalizeGetter(getter) {\n  if (!getter) {\n    return;\n  }\n\n  if (typeof getter === 'function') {\n    return getter;\n  }\n\n  return function () {\n    return getter;\n  };\n}\n\nfunction normalizePathGetter(getter) {\n  if (typeof getter === 'function') {\n    return getter;\n  }\n\n  return function (d) {\n    return get(d, getter);\n  };\n}\n\nfunction get(obj, path, def) {\n  if (typeof obj === 'function') {\n    try {\n      return obj();\n    } catch (e) {\n      return path;\n    }\n  }\n\n  if (!path) {\n    return obj;\n  }\n\n  var pathObj = makePathArray(path);\n  var val = void 0;\n\n  try {\n    val = pathObj.reduce(function (current, pathPart) {\n      return current[pathPart];\n    }, obj);\n  } catch (e) {// do nothing\n  }\n\n  return typeof val !== 'undefined' ? val : def;\n}\n\nfunction isArray(a) {\n  return Array.isArray(a);\n}\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj).join('.').replace('[', '.').replace(']', '').split('.');\n}\n\nfunction flattenDeep(arr) {\n  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!isArray(arr)) {\n    newArr.push(arr);\n  } else {\n    for (var i = 0; i < arr.length; i++) {\n      flattenDeep(arr[i], newArr);\n    }\n  }\n\n  return newArr;\n}\n\nfunction isValidPoint(d) {\n  if (d === null) {\n    return false;\n  }\n\n  if (typeof d === 'undefined') {\n    return false;\n  }\n\n  if (typeof d === 'string' && d === 'null') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getAxisByAxisID(axes, AxisID) {\n  return axes.find(function (d) {\n    return d.id === AxisID;\n  }) || axes[0];\n}\n\nfunction getAxisIndexByAxisID(axes, AxisID) {\n  var index = axes.findIndex(function (d) {\n    return d.id === AxisID;\n  });\n  return index > -1 ? index : 0;\n}\n\nfunction shallowCompare() {\n  var old = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _new = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var props = arguments[2];\n  var ignore = arguments[3];\n\n  if (!props) {\n    props = {};\n    Object.keys(old).forEach(function (key) {\n      props[key] = true;\n    });\n    Object.keys(_new).forEach(function (key) {\n      props[key] = true;\n    });\n    props = Object.keys(props);\n  }\n\n  if (ignore) {\n    for (var i = 0; i < props.length; i++) {\n      if (!ignore.includes(props[i])) {\n        if (old[props[i]] !== _new[props[i]]) {\n          return props[i] || true;\n        }\n      }\n    }\n  } else {\n    for (var _i2 = 0; _i2 < props.length; _i2++) {\n      if (old[props[_i2]] !== _new[props[_i2]]) {\n        return props[_i2] || true;\n      }\n    }\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}