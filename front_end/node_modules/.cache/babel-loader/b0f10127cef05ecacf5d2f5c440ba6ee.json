{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Context = require('../utils/Context');\n\nvar _Selectors = require('../utils/Selectors');\n\nvar _Selectors2 = _interopRequireDefault(_Selectors);\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _interactionMethods = require('../utils/interactionMethods');\n\nvar _Path = require('../primitives/Path');\n\nvar _Path2 = _interopRequireDefault(_Path);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n\n\nvar Pie = function (_React$PureComponent) {\n  _inherits(Pie, _React$PureComponent);\n\n  function Pie(props) {\n    _classCallCheck(this, Pie);\n\n    var _this = _possibleConstructorReturn(this, (Pie.__proto__ || Object.getPrototypeOf(Pie)).call(this, props));\n\n    if (!props.interaction) {\n      _this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          interaction: 'element'\n        });\n      });\n    }\n\n    _this.props.dispatch(function (state) {\n      return _extends({}, state, {\n        hoverMode: 'radial'\n      });\n    });\n\n    _this.selectSeries = _interactionMethods.selectSeries.bind(_this);\n    _this.hoverSeries = _interactionMethods.hoverSeries.bind(_this);\n    _this.selectDatum = _interactionMethods.selectDatum.bind(_this);\n    _this.hoverDatum = _interactionMethods.hoverDatum.bind(_this);\n    return _this;\n  }\n\n  _createClass(Pie, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          series = _props.series,\n          selected = _props.selected,\n          hovered = _props.hovered,\n          interaction = _props.interaction,\n          primaryAxes = _props.primaryAxes;\n\n      if (!primaryAxes.length) {\n        return;\n      }\n\n      var style = series.getStatusStyle(_Utils2.default.getStatus(series, hovered, selected));\n      var primaryAxis = primaryAxes[0];\n      var interactiveSeries = interaction === 'series';\n      var seriesInteractionProps = interactiveSeries ? {\n        onClick: function onClick() {\n          return _this2.selectSeries(series);\n        },\n        onMouseEnter: function onMouseEnter() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseMove: function onMouseMove() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.hoverSeries(null);\n        }\n      } : {};\n      return _react2.default.createElement('g', {\n        style: {\n          transform: 'translate3d(' + primaryAxis.width / 2 + 'px, ' + primaryAxis.height / 2 + 'px, 0)'\n        }\n      }, series.datums.map(function (datum, i) {\n        var dataStyle = datum.getStatusStyle(_Utils2.default.getStatus(datum, hovered, selected));\n        var interactiveDatum = interaction === 'element';\n        var datumInteractionProps = interactiveDatum ? {\n          onClick: function onClick() {\n            return _this2.selectDatum(datum);\n          },\n          onMouseEnter: function onMouseEnter() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseMove: function onMouseMove() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseLeave: function onMouseLeave() {\n            return _this2.hoverDatum(null);\n          }\n        } : {};\n        return _react2.default.createElement(_Path2.default, _extends({\n          key: i,\n          d: datum.arc(),\n          style: _extends({}, style, style.arc, dataStyle, dataStyle.arc, {\n            pointerEvents: interactiveDatum ? 'all' : 'none'\n          })\n        }, seriesInteractionProps, datumInteractionProps));\n      }));\n    }\n  }]);\n\n  return Pie;\n}(_react2.default.PureComponent);\n\nPie.defaultProps = {\n  showPoints: true\n};\n\nPie.plotDatum = function (datum, _ref) {\n  var primaryAxis = _ref.primaryAxis; // Decorate the datum with the scale info\n\n  datum = _extends({}, datum, primaryAxis.scale(datum), {\n    defined: _Utils2.default.isValidPoint(datum.xValue) && _Utils2.default.isValidPoint(datum.yValue) // Set the focus point\n\n  });\n  datum.focus = {\n    x: datum.x,\n    y: datum.y // Set the pointer points (used in voronoi)\n\n  };\n  datum.pointerPoints = [datum.focus]; // Return the new datum\n\n  return datum;\n};\n\nPie.buildStyles = function (series, _ref2) {\n  var getStyles = _ref2.getStyles,\n      getDatumStyles = _ref2.getDatumStyles,\n      defaultColors = _ref2.defaultColors;\n\n  series.getStatusStyle = function (status) {\n    series.style = _Utils2.default.getStatusStyle(series, status, getStyles);\n    return series.style;\n  }; // We also need to decorate each datum in the same fashion\n\n\n  series.datums.forEach(function (datum) {\n    datum.getStatusStyle = function (status) {\n      datum.style = _Utils2.default.getStatusStyle(datum, status, getDatumStyles, {\n        color: defaultColors[datum.index % (defaultColors.length - 1)]\n      });\n      return datum.style;\n    };\n  });\n};\n\nexports.default = (0, _Context.ChartConnect)(function () {\n  var selectors = {\n    primaryAxes: _Selectors2.default.primaryAxes()\n  };\n  return function (state) {\n    return {\n      primaryAxes: selectors.primaryAxes(state),\n      hovered: state.hovered,\n      selected: state.selected,\n      interaction: state.interaction\n    };\n  };\n})(Pie);","map":null,"metadata":{},"sourceType":"script"}