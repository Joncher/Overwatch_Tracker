{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nvar _ReactMove = require('./ReactMove');\n\nvar _Context = require('../utils/Context');\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Selectors = require('../utils/Selectors');\n\nvar _Selectors2 = _interopRequireDefault(_Selectors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n//\n\n\nvar triangleSize = 7;\nvar showCount = 10;\n\nvar getBackgroundColor = function getBackgroundColor(dark) {\n  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';\n};\n\nvar Tooltip = function (_React$PureComponent) {\n  _inherits(Tooltip, _React$PureComponent);\n\n  function Tooltip() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Tooltip);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.updateTooltip = function (force) {\n      var _this$props = _this.props,\n          focus = _this$props.focus,\n          align = _this$props.align,\n          padding = _this$props.padding,\n          tooltipArrowPadding = _this$props.tooltipArrowPadding,\n          onChange = _this$props.onChange,\n          hovered = _this$props.hovered,\n          primaryAxes = _this$props.primaryAxes,\n          secondaryAxes = _this$props.secondaryAxes,\n          gridX = _this$props.gridX,\n          gridY = _this$props.gridY,\n          gridWidth = _this$props.gridWidth,\n          gridHeight = _this$props.gridHeight,\n          width = _this$props.width,\n          height = _this$props.height,\n          pointer = _this$props.pointer,\n          dark = _this$props.dark;\n      var arrowPosition = _this.props.arrowPosition;\n      var alignPriority = _this.props.alignPriority;\n\n      if (!primaryAxes.length || !secondaryAxes.length) {\n        return null;\n      }\n\n      var hoveredDatums = hovered.datums && hovered.datums.length ? hovered.datums : []; // Get the closest focus datum out of the hoveredDatums\n\n      var focusDatum = _Utils2.default.getClosestPoint(pointer, hoveredDatums);\n\n      var active = hovered.active;\n\n      if (_this.focusDatum === focusDatum && _this.active === active && !force) {\n        return;\n      }\n\n      _this.focusDatum = focusDatum;\n      _this.lastActive = _this.active;\n      _this.active = active; // If there is a focusDatum, default the focus to its x and y\n\n      if (_this.focusDatum) {\n        _this.focus = _this.focusDatum.focus;\n      }\n\n      if (typeof focus === 'function') {\n        // Support functional override for focus\n        if (pointer) {\n          _this.focus = focus({\n            hoveredDatums: hoveredDatums,\n            pointer: pointer,\n            focusDatum: _this.focusDatum\n          });\n        }\n      } else if (focus === 'pointer') {\n        // Support pointer-bound focus\n        _this.focus = pointer;\n      } else if (focus === 'closest') {// Do nothing, this is already calculated\n      } else if (hoveredDatums && hoveredDatums.length) {\n        // Support manual definition of focus point using relative multiFocus strategy\n        var multiFocus = _Utils2.default.isArray(focus) ? [].concat(_toConsumableArray(focus)) : [focus];\n        _this.focus = _Utils2.default.getMultiFocus({\n          focus: multiFocus,\n          points: hoveredDatums,\n          gridX: gridX,\n          gridY: gridY,\n          gridWidth: gridWidth,\n          gridHeight: gridHeight,\n          width: width,\n          height: height\n        });\n      }\n\n      if (!_this.focus) {\n        return null;\n      }\n\n      var _this$focus = _this.focus,\n          x = _this$focus.x,\n          y = _this$focus.y,\n          _this$focus$horizonta = _this$focus.horizontalPadding,\n          horizontalPadding = _this$focus$horizonta === undefined ? 0 : _this$focus$horizonta,\n          _this$focus$verticalP = _this$focus.verticalPadding,\n          verticalPadding = _this$focus$verticalP === undefined ? 0 : _this$focus$verticalP;\n      var alignX = '0%';\n      var alignY = '-50%';\n      var triangleStyles = {};\n      var resolvedAlign = align || 'auto';\n      var backgroundColor = getBackgroundColor(dark);\n\n      if (align === 'auto') {\n        if (_this.el) {\n          var gridDims = _this.el.getBoundingClientRect();\n\n          var tooltipDims = _this.tooltipEl.getBoundingClientRect();\n\n          var container = _this.el;\n          var space = {\n            left: Infinity,\n            top: Infinity,\n            right: Infinity,\n            bottom: Infinity\n          };\n\n          while (container !== document.body) {\n            container = container.parentElement;\n\n            var _window$getComputedSt = window.getComputedStyle(container),\n                overflowX = _window$getComputedSt.overflowX,\n                overflowY = _window$getComputedSt.overflowY;\n\n            if (container === document.body || [overflowX, overflowY].find(function (d) {\n              return ['auto', 'hidden'].includes(d);\n            })) {\n              var containerDims = container.getBoundingClientRect();\n              var left = gridDims.left - containerDims.left + _this.focus.x;\n              var top = gridDims.top - containerDims.top + _this.focus.y;\n              var right = containerDims.width - left;\n              var bottom = containerDims.height - top;\n              space.left = Math.min(space.left, left);\n              space.top = Math.min(space.top, top);\n              space.right = Math.min(space.right, right);\n              space.bottom = Math.min(space.bottom, bottom);\n            }\n          }\n\n          resolvedAlign = null;\n          alignPriority.forEach(function (priority) {\n            if (resolvedAlign) {\n              return;\n            }\n\n            if (priority === 'left') {\n              if (space.left - tooltipArrowPadding - padding - horizontalPadding > tooltipDims.width && space.top > tooltipDims.height / 2 && space.bottom > tooltipDims.height / 2) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'right') {\n              if (space.right - tooltipArrowPadding - padding - horizontalPadding > tooltipDims.width && space.top > tooltipDims.height / 2 && space.bottom > tooltipDims.height / 2) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'top') {\n              if (space.top - tooltipArrowPadding - padding - verticalPadding > tooltipDims.height && space.left > tooltipDims.width / 2 && space.right > tooltipDims.width / 2) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'bottom') {\n              if (space.bottom - tooltipArrowPadding - padding - verticalPadding > tooltipDims.height && space.left > tooltipDims.width / 2 && space.right > tooltipDims.width / 2) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'topLeft') {\n              if (space.top - tooltipArrowPadding > tooltipDims.height && space.left - tooltipArrowPadding > tooltipDims.width) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'topRight') {\n              if (space.top - tooltipArrowPadding > tooltipDims.height && space.right - tooltipArrowPadding > tooltipDims.width) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'bottomLeft') {\n              if (space.bottom - tooltipArrowPadding > tooltipDims.height && space.left - tooltipArrowPadding > tooltipDims.width) {\n                resolvedAlign = priority;\n              }\n            } else if (priority === 'bottomRight') {\n              if (space.bottom - tooltipArrowPadding > tooltipDims.height && space.right - tooltipArrowPadding > tooltipDims.width) {\n                resolvedAlign = priority;\n              }\n            }\n          });\n        }\n      }\n\n      if (resolvedAlign === 'top') {\n        alignX = '-50%';\n        alignY = '-100%';\n      } else if (resolvedAlign === 'topRight') {\n        alignX = '0%';\n        alignY = '-100%';\n      } else if (resolvedAlign === 'right') {\n        alignX = '0%';\n        alignY = '-50%';\n      } else if (resolvedAlign === 'bottomRight') {\n        alignX = '0%';\n        alignY = '0%';\n      } else if (resolvedAlign === 'bottom') {\n        alignX = '-50%';\n        alignY = '0%';\n      } else if (resolvedAlign === 'bottomLeft') {\n        alignX = '-100%';\n        alignY = '0%';\n      } else if (resolvedAlign === 'left') {\n        alignX = '-100%';\n        alignY = '-50%';\n      } else if (resolvedAlign === 'topLeft') {\n        alignX = '-100%';\n        alignY = '-100%';\n      }\n\n      if (!arrowPosition) {\n        if (resolvedAlign === 'left') {\n          arrowPosition = 'right';\n        } else if (resolvedAlign === 'right') {\n          arrowPosition = 'left';\n        } else if (resolvedAlign === 'top') {\n          arrowPosition = 'bottom';\n        } else if (resolvedAlign === 'bottom') {\n          arrowPosition = 'top';\n        }\n      }\n\n      if (arrowPosition === 'bottom') {\n        triangleStyles = {\n          top: '100%',\n          left: '50%',\n          transform: 'translate3d(-50%, 0%, 0)',\n          borderLeft: triangleSize * 0.8 + 'px solid transparent',\n          borderRight: triangleSize * 0.8 + 'px solid transparent',\n          borderTop: triangleSize + 'px solid ' + backgroundColor\n        };\n      } else if (arrowPosition === 'top') {\n        triangleStyles = {\n          top: '0%',\n          left: '50%',\n          transform: 'translate3d(-50%, -100%, 0)',\n          borderLeft: triangleSize * 0.8 + 'px solid transparent',\n          borderRight: triangleSize * 0.8 + 'px solid transparent',\n          borderBottom: triangleSize + 'px solid ' + backgroundColor\n        };\n      } else if (arrowPosition === 'right') {\n        triangleStyles = {\n          top: '50%',\n          left: '100%',\n          transform: 'translate3d(0%, -50%, 0)',\n          borderTop: triangleSize * 0.8 + 'px solid transparent',\n          borderBottom: triangleSize * 0.8 + 'px solid transparent',\n          borderLeft: triangleSize + 'px solid ' + backgroundColor\n        };\n      } else if (arrowPosition === 'left') {\n        triangleStyles = {\n          top: '50%',\n          left: '0%',\n          transform: 'translate3d(-100%, -50%, 0)',\n          borderTop: triangleSize * 0.8 + 'px solid transparent',\n          borderBottom: triangleSize * 0.8 + 'px solid transparent',\n          borderRight: triangleSize + 'px solid ' + backgroundColor\n        };\n      } else {\n        triangleStyles = {\n          opacity: 0\n        };\n      }\n\n      var opacity = hovered.active ? 1 : 0;\n\n      var primaryAxis = _Utils2.default.getAxisByAxisID(primaryAxes, _this.focusDatum ? _this.focusDatum.series.primaryAxisID : null);\n\n      var secondaryAxis = _Utils2.default.getAxisByAxisID(secondaryAxes, _this.focusDatum ? _this.focusDatum.series.secondaryAxisID : null);\n\n      var tooltip = {\n        x: x,\n        y: y,\n        horizontalPadding: horizontalPadding,\n        verticalPadding: verticalPadding,\n        alignX: alignX,\n        alignY: alignY,\n        triangleStyles: triangleStyles,\n        opacity: opacity,\n        primaryAxis: primaryAxis,\n        secondaryAxis: secondaryAxis,\n        focusDatum: _this.focusDatum\n      };\n      onChange(tooltip);\n\n      _this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          tooltip: tooltip\n        });\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Tooltip, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(oldProps) {\n      if (oldProps.pointer !== this.props.pointer) {\n        this.updateTooltip();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          _props$offset = _props.offset,\n          left = _props$offset.left,\n          top = _props$offset.top,\n          gridX = _props.gridX,\n          gridY = _props.gridY,\n          gridWidth = _props.gridWidth,\n          gridHeight = _props.gridHeight,\n          tooltip = _props.tooltip,\n          padding = _props.padding,\n          primaryAxes = _props.primaryAxes,\n          secondaryAxes = _props.secondaryAxes,\n          tooltipArrowPadding = _props.tooltipArrowPadding,\n          children = _props.children,\n          render = _props.render,\n          dark = _props.dark,\n          Comp = _props.Component,\n          rest = _objectWithoutProperties(_props, ['offset', 'gridX', 'gridY', 'gridWidth', 'gridHeight', 'tooltip', 'padding', 'primaryAxes', 'secondaryAxes', 'tooltipArrowPadding', 'children', 'render', 'dark', 'Component']);\n\n      var x = tooltip.x,\n          y = tooltip.y,\n          horizontalPadding = tooltip.horizontalPadding,\n          verticalPadding = tooltip.verticalPadding,\n          alignX = tooltip.alignX,\n          alignY = tooltip.alignY,\n          triangleStyles = tooltip.triangleStyles,\n          _tooltip$opacity = tooltip.opacity,\n          opacity = _tooltip$opacity === undefined ? 0 : _tooltip$opacity,\n          primaryAxis = tooltip.primaryAxis,\n          secondaryAxis = tooltip.secondaryAxis;\n      var resolvedHorizontalPadding = padding + horizontalPadding;\n      var resolvedVerticalPadding = padding + verticalPadding;\n      var start = {\n        opacity: 0\n      };\n      var update = {\n        opacity: opacity,\n        left: left + gridX + 'px',\n        top: top + gridY + 'px',\n        width: gridWidth + 'px',\n        height: gridHeight + 'px'\n      };\n      var renderedChildren = void 0;\n\n      var renderProps = _extends({\n        datum: this.focusDatum,\n        getStyle: function getStyle(datum) {\n          return datum.getStatusStyle(_Utils2.default.getStatus(datum, rest.hovered, rest.selected));\n        },\n        primaryAxes: primaryAxes,\n        secondaryAxes: secondaryAxes,\n        primaryAxis: primaryAxis,\n        secondaryAxis: secondaryAxis\n      }, rest);\n\n      if (Comp) {\n        renderedChildren = _react2.default.createElement(Comp, null, _extends({}, rest, renderProps));\n      } else {\n        renderedChildren = (render || children)(renderProps);\n      }\n\n      return _react2.default.createElement(_ReactMove.Animate, {\n        show: !!opacity,\n        start: start,\n        enter: update,\n        update: update,\n        leave: update,\n        className: 'tooltip-wrap',\n        style: {\n          pointerEvents: 'none',\n          position: 'absolute'\n        },\n        innerRef: function innerRef(el) {\n          _this2.el = el;\n        }\n      }, _react2.default.createElement('div', {\n        style: {\n          position: 'absolute',\n          left: 0,\n          top: 0,\n          transform: 'translate3d(' + x + 'px, ' + y + 'px, 0px)',\n          transition: 'all .2s ease-out'\n        }\n      }, _react2.default.createElement('div', {\n        style: {\n          transform: 'translate3d(' + alignX + ', ' + alignY + ', 0)',\n          padding: tooltipArrowPadding + resolvedVerticalPadding + 'px ' + (tooltipArrowPadding + resolvedHorizontalPadding) + 'px',\n          width: 'auto',\n          transition: 'all .2s ease-out'\n        }\n      }, _react2.default.createElement('div', {\n        ref: function ref(el) {\n          _this2.tooltipEl = el;\n\n          if (_this2.active && !_this2.lastActive) {\n            (0, _raf2.default)(function () {\n              return _this2.updateTooltip(true);\n            });\n          }\n        },\n        style: {\n          fontSize: '12px',\n          padding: '5px',\n          background: getBackgroundColor(dark),\n          color: dark ? 'black' : 'white',\n          borderRadius: '3px',\n          position: 'relative',\n          transition: 'all .2s ease-out'\n        }\n      }, _react2.default.createElement('div', {\n        style: _extends({\n          position: 'absolute',\n          width: 0,\n          height: 0\n        }, triangleStyles, {\n          transition: 'all .2s ease-out'\n        })\n      }), renderedChildren))));\n    }\n  }]);\n\n  return Tooltip;\n}(_react2.default.PureComponent);\n\nTooltip.defaultProps = {\n  focus: 'closest',\n  align: 'auto',\n  alignPriority: ['right', 'top', 'left', 'bottom', 'topRight', 'topLeft', 'bottomLeft', 'bottomRight'],\n  children: defaultRenderer,\n  padding: 1,\n  tooltipArrowPadding: 7,\n  onChange: function onChange() {}\n};\nTooltip.isHtml = true;\n\nfunction defaultRenderer(props) {\n  var datum = props.datum,\n      primaryAxis = props.primaryAxis,\n      secondaryAxis = props.secondaryAxis,\n      formatSecondary = props.formatSecondary,\n      getStyle = props.getStyle,\n      dark = props.dark;\n\n  if (!datum) {\n    return null;\n  }\n\n  var resolvedFormatSecondary = formatSecondary || function (val) {\n    return Math.floor(val) < val ? secondaryAxis.format(Math.round(val * 100) / 100) : secondaryAxis.format(val);\n  };\n\n  var sortedGroupDatums = secondaryAxis && secondaryAxis.stacked ? [].concat(_toConsumableArray(datum.group)).reverse() : [].concat(_toConsumableArray(datum.group)).sort(function (a, b) {\n    if (a.secondary < b.secondary) {\n      return -1;\n    } else if (a.secondary > b.secondary) {\n      return 1;\n    }\n\n    return a.seriesIndex < b.seriesIndex ? 1 : -1;\n  }).reverse();\n\n  if (secondaryAxis.invert) {\n    sortedGroupDatums.reverse();\n  }\n\n  var resolvedShowCount = showCount % 2 === 0 ? showCount : showCount + 1;\n  var length = sortedGroupDatums.length; // Get the hovered series' index\n\n  var activeIndex = sortedGroupDatums.findIndex(function (d) {\n    return d === datum;\n  }); // Get the start by going back half of the showCount\n\n  var start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0; // Make sure it's at least 0\n\n  start = Math.max(start, 0); // Use the start and add the showCount to get the end\n\n  var end = activeIndex > -1 ? start + resolvedShowCount : length; // Don't let the end go passed the length\n\n  end = Math.min(end, length); // Double check we aren't clipping the start\n\n  start = Math.max(end - resolvedShowCount, 0); // Slice the datums by start and end\n\n  var visibleSortedGroupDatums = sortedGroupDatums.slice(start, end); // Detect if we have previous items\n\n  var hasPrevious = start > 0; // Or next items\n\n  var hasNext = end < length;\n  return _react2.default.createElement('div', null, _react2.default.createElement('div', {\n    style: {\n      marginBottom: '3px',\n      textAlign: 'center'\n    }\n  }, _react2.default.createElement('strong', null, primaryAxis.format(datum.primary))), _react2.default.createElement('table', {\n    style: {\n      whiteSpace: 'nowrap'\n    }\n  }, _react2.default.createElement('tbody', null, hasPrevious ? _react2.default.createElement('tr', {\n    style: {\n      opacity: 0.8\n    }\n  }, _react2.default.createElement('td', null), _react2.default.createElement('td', null, '...'), _react2.default.createElement('td', null)) : null, visibleSortedGroupDatums.map(function (sortedDatum, i) {\n    var active = sortedDatum === datum;\n    return _react2.default.createElement('tr', {\n      key: i,\n      style: {\n        opacity: active ? 1 : 0.8\n      }\n    }, _react2.default.createElement('td', {\n      style: {\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        marginRight: '5px'\n      }\n    }, _react2.default.createElement('svg', {\n      width: '16',\n      height: '16'\n    }, _react2.default.createElement('circle', {\n      cx: '8',\n      cy: '8',\n      style: _extends({}, getStyle(sortedDatum), {\n        r: 7,\n        stroke: dark ? 'black' : 'white',\n        strokeWidth: active ? 2 : 1\n      })\n    }))), _react2.default.createElement('td', null, sortedDatum.seriesLabel, ': \\xA0'), _react2.default.createElement('td', {\n      style: {\n        textAlign: 'right'\n      }\n    }, resolvedFormatSecondary(sortedDatum.secondary)));\n  }), hasNext ? _react2.default.createElement('tr', {\n    style: {\n      opacity: 0.8\n    }\n  }, _react2.default.createElement('td', null), _react2.default.createElement('td', null, '...'), _react2.default.createElement('td', null)) : null, secondaryAxis && secondaryAxis.stacked && datum.group.length > 1 ? _react2.default.createElement('tr', null, _react2.default.createElement('td', {\n    style: {\n      paddingTop: '5px'\n    }\n  }, _react2.default.createElement('div', {\n    style: {\n      width: '12px',\n      height: '12px',\n      backgroundColor: dark ? 'rgba(0, 26, 39, 0.3)' : 'rgba(255,255,255,.2)',\n      borderRadius: '50px'\n    }\n  })), _react2.default.createElement('td', {\n    style: {\n      paddingTop: '5px'\n    }\n  }, 'Total: \\xA0'), _react2.default.createElement('td', {\n    style: {\n      paddingTop: '5px'\n    }\n  }, resolvedFormatSecondary([].concat(_toConsumableArray(datum.group)).reverse()[0].totalValue))) : null)));\n}\n\nexports.default = (0, _Context.PointerConnect)(function (state) {\n  return {\n    pointer: state.pointer\n  };\n})((0, _Context.ChartConnect)(function () {\n  var selectors = {\n    primaryAxes: _Selectors2.default.primaryAxes(),\n    secondaryAxes: _Selectors2.default.secondaryAxes(),\n    gridX: _Selectors2.default.gridX(),\n    gridY: _Selectors2.default.gridY(),\n    gridWidth: _Selectors2.default.gridWidth(),\n    gridHeight: _Selectors2.default.gridHeight(),\n    offset: _Selectors2.default.offset()\n  };\n  return function (state) {\n    return {\n      primaryAxes: selectors.primaryAxes(state),\n      secondaryAxes: selectors.secondaryAxes(state),\n      gridX: selectors.gridX(state),\n      gridY: selectors.gridY(state),\n      gridWidth: selectors.gridWidth(state),\n      gridHeight: selectors.gridHeight(state),\n      width: state.width,\n      height: state.height,\n      hovered: state.hovered,\n      tooltip: state.tooltip,\n      offset: selectors.offset(state),\n      dark: state.dark\n    };\n  };\n})(Tooltip));","map":null,"metadata":{},"sourceType":"script"}