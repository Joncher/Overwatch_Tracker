{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Animate = exports.easings = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* eslint-disable no-restricted-syntax, react/forbid-prop-types */\n\n\nvar easings = exports.easings = {\n  // Cubic\n  easeInCubic: 'cubic-bezier(0.550, 0.055, 0.675, 0.190)',\n  easeOutCubic: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)',\n  easeInOutCubic: 'cubic-bezier(0.645, 0.045, 0.355, 1.000)',\n  // Circ\n  easeInCirc: 'cubic-bezier(0.600, 0.040, 0.980, 0.335)',\n  easeOutCirc: 'cubic-bezier(0.075, 0.820, 0.165, 1.000)',\n  easeInOutCirc: 'cubic-bezier(0.785, 0.135, 0.150, 0.860)',\n  // Expo\n  easeInExpo: 'cubic-bezier(0.950, 0.050, 0.795, 0.035)',\n  easeOutExpo: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',\n  easeInOutExpo: 'cubic-bezier(1.000, 0.000, 0.000, 1.000)',\n  // Quad\n  easeInQuad: 'cubic-bezier(0.550, 0.085, 0.680, 0.530)',\n  easeOutQuad: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n  easeInOutQuad: 'cubic-bezier(0.455, 0.030, 0.515, 0.955)',\n  // Quart\n  easeInQuart: 'cubic-bezier(0.895, 0.030, 0.685, 0.220)',\n  easeOutQuart: 'cubic-bezier(0.165, 0.840, 0.440, 1.000)',\n  easeInOutQuart: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',\n  // Quint\n  easeInQuint: 'cubic-bezier(0.755, 0.050, 0.855, 0.060)',\n  easeOutQuint: 'cubic-bezier(0.230, 1.000, 0.320, 1.000)',\n  easeInOutQuint: 'cubic-bezier(0.860, 0.000, 0.070, 1.000)',\n  // Sine\n  easeInSine: 'cubic-bezier(0.470, 0.000, 0.745, 0.715)',\n  easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',\n  easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)',\n  // Back\n  easeInBack: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',\n  easeOutBack: 'cubic-bezier(0.175,  0.885, 0.320, 1.275)',\n  easeInOutBack: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)'\n};\n\nvar Animate = exports.Animate = function (_React$Component) {\n  _inherits(Animate, _React$Component);\n\n  function Animate(props) {\n    _classCallCheck(this, Animate);\n\n    var _this = _possibleConstructorReturn(this, (Animate.__proto__ || Object.getPrototypeOf(Animate)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var _this$props = _this.props,\n        show = _this$props.show,\n        preMount = _this$props.preMount,\n        transitionOnMount = _this$props.transitionOnMount,\n        start = _this$props.start,\n        enter = _this$props.enter;\n    _this.stage = false;\n    _this.stageStyles = {};\n    _this.transitioning = false;\n    _this.state = {\n      mountContent: preMount || show,\n      currentStyle: transitionOnMount ? start : enter,\n      styleOverrides: {}\n    };\n    return _this;\n  }\n\n  _createClass(Animate, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          transitionOnMount = _props.transitionOnMount,\n          show = _props.show,\n          enter = _props.enter;\n\n      if (transitionOnMount && show) {\n        this.transition('enter', enter);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(oldProps) {\n      var _props2 = this.props,\n          show = _props2.show,\n          enter = _props2.enter,\n          leave = _props2.leave,\n          start = _props2.start,\n          stage = this.stage;\n\n      if (show) {\n        // Entering\n        if (!oldProps.show) {\n          if (stage === 'leave') {\n            return this.transition('clean');\n          }\n\n          if (enter) {\n            return this.transition('enter', enter);\n          }\n\n          return this.transition('clean');\n        } // Did Enter\n\n\n        if (stage === 'didEnter') {\n          return this.transition('clean');\n        }\n      } else if (oldProps.show) {\n        // Leaving\n        return this.transition('leave', leave || start);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props3 = this.props,\n          Comp = _props3.component,\n          children = _props3.children,\n          originalShow = _props3.show,\n          easing = _props3.easing,\n          duration = _props3.duration,\n          transitionProperty = _props3.transitionProperty,\n          stayMounted = _props3.stayMounted,\n          transitionOnMount = _props3.transitionOnMount,\n          show = _props3.show,\n          style = _props3.style,\n          leave = _props3.leave,\n          enter = _props3.enter,\n          innerRef = _props3.innerRef,\n          onFinish = _props3.onFinish,\n          preMount = _props3.preMount,\n          rest = _objectWithoutProperties(_props3, ['component', 'children', 'show', 'easing', 'duration', 'transitionProperty', 'stayMounted', 'transitionOnMount', 'show', 'style', 'leave', 'enter', 'innerRef', 'onFinish', 'preMount']);\n\n      var _state = this.state,\n          mountContent = _state.mountContent,\n          currentStyle = _state.currentStyle,\n          styleOverrides = _state.styleOverrides;\n      return mountContent ? _react2.default.createElement(Comp, _extends({\n        ref: function ref(el) {\n          _this2.handleRef(el);\n\n          if (innerRef) {\n            innerRef(el);\n          }\n        },\n        onTransitionEnd: this.transitionEnd,\n        style: this.makeStyles(currentStyle, styleOverrides)\n      }, rest), children) : null;\n    }\n  }]);\n\n  return Animate;\n}(_react2.default.Component); // I'll let someone smarter than me figure out how to do this ;)\n// export class AnimateGroup extends React.Component {\n//   constructor (props) {\n//     super(props)\n//     const { data } = props\n//     this.nodes = this.makeNodes(data)\n//   }\n//   componentDidUpdate () {\n//     const { data } = this.props\n//     const newNodes = this.makeNodes(data)\n//     let needsUpdate\n//     if (newNodes.some(node => !this.nodes.find(d => d.key === node.key))) {\n//       needsUpdate = 'diff'\n//     }\n//     if (needsUpdate) {\n//       console.log(needsUpdate, newNodes, this.nodes)\n//       this.nodes = this.updateNodes(newNodes)\n//       this.forceUpdate()\n//     }\n//   }\n//   makeNodes = data => {\n//     const { getKey } = this.props\n//     return data.map(datum => ({\n//       key: getKey(datum),\n//       data: datum,\n//       show: true,\n//     }))\n//   }\n//   updateNodes = next => {\n//     const nodes = []\n//     this.nodes.forEach(node => {\n//       if (next.find(d => d.key === node.key)) {\n//         return\n//       }\n//       exiting.push({\n//         ...node,\n//         show: false,\n//       })\n//     })\n//     return [...next, ...exiting]\n//   }\n//   removeNode = node => {\n//     this.nodes = this.nodes.filter(d => d.key !== node.key)\n//     this.forceUpdate()\n//   }\n//   render () {\n//     const {\n//       data,\n//       getKey,\n//       children,\n//       render,\n//       start,\n//       enter,\n//       update,\n//       leave,\n//       duration,\n//       easing,\n//       ...rest\n//     } = this.props\n//     return (\n//       <React.Fragment>\n//         {this.nodes.map((node, i) => (\n//           <Animate\n//             key={node.key}\n//             show={node.show}\n//             start={typeof start === 'function' ? start(node.data, node.key, i) : start}\n//             enter={typeof enter === 'function' ? enter(node.data, node.key, i) : enter}\n//             update={typeof update === 'function' ? update(node.data, node.key, i) : update}\n//             leave={typeof leave === 'function' ? leave(node.data, node.key, i) : leave}\n//             onFinish={() => {\n//               if (!node.show) {\n//                 this.removeNode(node)\n//               }\n//             }}\n//             {...rest}\n//           >\n//             {(render || children)(node.data)}\n//           </Animate>\n//         ))}\n//       </React.Fragment>\n//     )\n//   }\n// }\n// function mergeNodes (left, right) {\n//   let nodes = []\n//   let lastRightIndex = 0\n//   left.forEach(l => {\n//     const index = right.findIndex(r => r.key === l.key)\n//     if (index === -1) {\n//       return nodes.push(l)\n//     }\n//     nodes = [...nodes, ...right.slice(lastRightIndex, index)]\n//     lastRightIndex = index\n//   })\n//   return nodes\n// }\n\n\nAnimate.easings = easings;\nAnimate.propTypes = {\n  component: _propTypes2.default.string,\n  show: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.number]),\n  easing: _propTypes2.default.string,\n  duration: _propTypes2.default.number,\n  preMount: _propTypes2.default.bool,\n  transitionProperty: _propTypes2.default.string,\n  stayMounted: _propTypes2.default.bool,\n  style: _propTypes2.default.object,\n  start: _propTypes2.default.object,\n  enter: _propTypes2.default.object,\n  leave: _propTypes2.default.object,\n  onFinish: _propTypes2.default.func,\n  transitionOnMount: _propTypes2.default.bool,\n  children: _propTypes2.default.node.isRequired\n};\nAnimate.defaultProps = {\n  component: 'div',\n  show: true,\n  easing: 'easeOutQuad',\n  duration: 300,\n  transitionProperty: 'all',\n  preMount: false,\n  stayMounted: true,\n  transitionOnMount: false,\n  style: undefined,\n  start: undefined,\n  enter: undefined,\n  leave: undefined,\n  onFinish: function onFinish() {}\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.ensureMounted = function () {\n    return new Promise(function (resolve) {\n      var check = function check() {\n        if (_this3.el) {\n          return resolve();\n        }\n\n        (0, _raf2.default)(function () {\n          _this3.setState({\n            mountContent: true\n          }, check);\n        });\n      };\n\n      check();\n    });\n  };\n\n  this.setCurrentStyle = function (style) {\n    return _this3.setState({\n      currentStyle: style\n    });\n  };\n\n  this.overrideStyle = function (style) {\n    return new Promise(function (resolve) {\n      var check = function check() {\n        _this3.setState({\n          styleOverrides: style\n        }, function () {\n          (0, _raf2.default)(function () {\n            if (Object.keys(style).some(function (key) {\n              return !_this3.el || _this3.el.style[key] !== style[key];\n            })) {\n              return check();\n            }\n\n            resolve();\n          });\n        });\n      };\n\n      check();\n    });\n  };\n\n  this.transition = function (stage) {\n    var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var show = _this3.props.show;\n    _this3.stage = stage;\n    _this3.stageStyles = styles;\n    _this3.transitioning = true;\n    var wasAutoWidth = void 0;\n    var wasAutoHeight = void 0;\n    var isAutoWidth = void 0;\n    var isAutoHeight = void 0;\n    var isAutoChanged = void 0;\n    return Promise.resolve().then(function () {\n      if (show) {\n        return _this3.ensureMounted();\n      }\n    }).then(function () {\n      var _state2 = _this3.state,\n          currentStyle = _state2.currentStyle,\n          styleOverrides = _state2.styleOverrides;\n\n      var previousStyle = _this3.makeStyles(currentStyle, styleOverrides);\n\n      var nextStyle = _this3.makeStyles(styles);\n\n      wasAutoWidth = _this3.isProp(previousStyle, 'width', 'auto');\n      wasAutoHeight = _this3.isProp(previousStyle, 'height', 'auto');\n      isAutoWidth = _this3.isProp(nextStyle, 'width', 'auto');\n      isAutoHeight = _this3.isProp(nextStyle, 'height', 'auto');\n      var isAutoWidthChanged = wasAutoWidth !== isAutoWidth;\n      var isAutoHeightChanged = wasAutoHeight !== isAutoHeight;\n      isAutoChanged = isAutoWidthChanged || isAutoHeightChanged;\n\n      if (isAutoChanged) {\n        // First we have to make sure we are measuring an\n        // inline-block element that is overflow hidden, otherwise measurements\n        // can get very inaccurate\n        return _this3.overrideStyle({\n          display: 'block',\n          overflow: 'hidden'\n        }).then(function () {\n          // Then we measure\n          var measurements = _this3.measure(); // Make sure overflow is hidden while we animate\n\n\n          return _this3.overrideStyle(_extends({}, isAutoWidthChanged ? {\n            width: measurements.width + 'px'\n          } : {}, isAutoHeightChanged ? {\n            height: measurements.height + 'px'\n          } : {}));\n        });\n      }\n    }).then(function () {\n      (0, _raf2.default)(function () {\n        _this3.setState(function (_ref) {\n          var styleOverrides = _ref.styleOverrides;\n          styleOverrides = isAutoChanged ? _extends({}, styleOverrides, wasAutoWidth ? {\n            width: styles.width\n          } : {}, wasAutoHeight ? {\n            height: styles.height\n          } : {}) : styleOverrides;\n          return {\n            mountContent: true,\n            currentStyle: styles,\n            styleOverrides: styleOverrides\n          };\n        }, function () {// If no styles were applied, then we need to manually complete the transition\n          // TODO: this might also need to be done if the transitionProperty doesn't\n          // match any of the styles provided.\n          // if (!styles) {\n          //   this.completeTransition();\n          // }\n        });\n      });\n    });\n  };\n\n  this.transitionEnd = function (e) {\n    if (e) {\n      e.persist(); // Only handle transitionEnd for this element\n\n      if (e.target !== _this3.el) {\n        return;\n      }\n    } // We have to debounce the action of stopping\n    // the \"transition\" state, since onTransitionEnd\n    // will fire more than once if there are multiple\n    // properties that were transitioned.\n\n\n    if (_this3.transitionRAF) {\n      _raf2.default.cancel(_this3.transitionRAF);\n    }\n\n    _this3.transitionRAF = (0, _raf2.default)(_this3.completeTransition);\n  };\n\n  this.completeTransition = function () {\n    var _props4 = _this3.props,\n        stayMounted = _props4.stayMounted,\n        onFinish = _props4.onFinish;\n    var shouldHide = _this3.stage === 'leave';\n    _this3.transitioning = false;\n\n    if (_this3.stage === 'enter') {\n      _this3.stage = 'didEnter';\n    } else if (_this3.stage === 'mount') {\n      _this3.stage = 'mounted';\n    } else {\n      _this3.stage = false;\n    }\n\n    _this3.setState({\n      mountContent: !(shouldHide && !stayMounted),\n      styleOverrides: {} // This is to make sure the auto/hidden overrides are gone\n\n    }, onFinish);\n  };\n\n  this.handleRef = function (el) {\n    _this3.el = el;\n  };\n\n  this.isProp = function (style, prop, value) {\n    return style[prop] === value;\n  };\n\n  this.measure = function () {\n    if (!_this3.el) {\n      return {};\n    }\n\n    return {\n      width: _this3.el.scrollWidth,\n      height: _this3.el.scrollHeight\n    };\n  };\n\n  this.makeStyles = function () {\n    var currentStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _props5 = _this3.props,\n        style = _props5.style,\n        transitionProperty = _props5.transitionProperty,\n        duration = _props5.duration,\n        easing = _props5.easing;\n    var resolvedEasing = easings[easing] || easing || 'ease-out';\n    return _extends({\n      transitionProperty: transitionProperty,\n      transitionDuration: duration + 'ms',\n      transitionTimingFunction: '' + resolvedEasing\n    }, style, currentStyle, overrides);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}