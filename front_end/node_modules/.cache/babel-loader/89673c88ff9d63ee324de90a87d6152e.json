{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _d3Shape = require('d3-shape');\n\nvar _Context = require('../utils/Context');\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Curves = require('../utils/Curves');\n\nvar _Curves2 = _interopRequireDefault(_Curves);\n\nvar _interactionMethods = require('../utils/interactionMethods');\n\nvar _Path = require('../primitives/Path');\n\nvar _Path2 = _interopRequireDefault(_Path);\n\nvar _Circle = require('../primitives/Circle');\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n\n\nvar pathDefaultStyle = {\n  strokeWidth: 2\n};\nvar circleDefaultStyle = {\n  r: 2\n};\n\nvar Line = function (_React$PureComponent) {\n  _inherits(Line, _React$PureComponent);\n\n  function Line(props) {\n    _classCallCheck(this, Line);\n\n    var _this = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    if (!props.hoverMode) {\n      _this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          hoverMode: 'primary'\n        });\n      });\n    }\n\n    _this.selectSeries = _interactionMethods.selectSeries.bind(_this);\n    _this.hoverSeries = _interactionMethods.hoverSeries.bind(_this);\n    _this.selectDatum = _interactionMethods.selectDatum.bind(_this);\n    _this.hoverDatum = _interactionMethods.hoverDatum.bind(_this);\n    return _this;\n  }\n\n  _createClass(Line, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.updatePath(this.props);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(oldProps) {\n      if (this.props.series !== oldProps.series) {\n        this.updatePath(this.props);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          series = _props.series,\n          visibility = _props.visibility,\n          showPoints = _props.showPoints,\n          selected = _props.selected,\n          hovered = _props.hovered,\n          interaction = _props.interaction;\n      var path = this.state.path;\n\n      var status = _Utils2.default.getStatus(series, hovered, selected);\n\n      var style = series.getStatusStyle(status);\n      var interactiveSeries = interaction === 'series';\n      var seriesInteractionProps = interactiveSeries ? {\n        onClick: function onClick() {\n          return _this2.selectSeries(series);\n        },\n        onMouseEnter: function onMouseEnter() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseMove: function onMouseMove() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.hoverSeries(null);\n        }\n      } : {};\n      var pointerEvents = interactiveSeries ? 'all' : 'none';\n      return _react2.default.createElement('g', null, _react2.default.createElement(_Path2.default, _extends({\n        d: path,\n        style: _extends({}, pathDefaultStyle, style, style.line, {\n          fill: 'none',\n          pointerEvents: pointerEvents\n        }),\n        opacity: visibility\n      }, seriesInteractionProps)), showPoints && series.datums.map(function (datum, i) {\n        if (!datum.defined) {\n          return null;\n        }\n\n        var dataStyle = datum.getStatusStyle(_Utils2.default.getStatus(datum, hovered, selected));\n        var interactiveDatum = interaction === 'element';\n        var datumInteractionProps = interactiveDatum ? {\n          onClick: function onClick() {\n            return _this2.selectDatum(datum);\n          },\n          onMouseEnter: function onMouseEnter() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseMove: function onMouseMove() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseLeave: function onMouseLeave() {\n            return _this2.hoverDatum(null);\n          }\n        } : {};\n        return _react2.default.createElement(_Circle2.default, _extends({\n          key: i,\n          x: datum ? datum.x : undefined,\n          y: datum ? datum.y : undefined,\n          style: _extends({}, circleDefaultStyle, style, style.circle, dataStyle, dataStyle.circle, {\n            pointerEvents: interactiveDatum ? 'all' : 'none'\n          }),\n          opacity: visibility\n        }, seriesInteractionProps, datumInteractionProps));\n      }));\n    }\n  }]);\n\n  return Line;\n}(_react2.default.PureComponent);\n\nLine.defaultProps = {\n  showPoints: true,\n  curve: 'monotoneX'\n};\n\nLine.plotDatum = function (datum, _ref) {\n  var primaryAxis = _ref.primaryAxis,\n      xAxis = _ref.xAxis,\n      yAxis = _ref.yAxis;\n  datum.x = xAxis.scale(datum.xValue);\n  datum.y = yAxis.scale(datum.yValue);\n  datum.defined = _Utils2.default.isValidPoint(datum.xValue) && _Utils2.default.isValidPoint(datum.yValue);\n  datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Adjust non-bar elements for ordinal scales\n\n  if (xAxis.type === 'ordinal') {\n    datum.x += xAxis.tickOffset;\n  }\n\n  if (yAxis.type === 'ordinal') {\n    datum.y += yAxis.tickOffset;\n  } // Set the default focus point\n\n\n  datum.focus = {\n    x: datum.x,\n    y: datum.y // Set the pointer points (used in voronoi)\n\n  };\n  datum.pointerPoints = [datum.focus];\n};\n\nLine.buildStyles = function (series, _ref2) {\n  var getStyles = _ref2.getStyles,\n      getDatumStyles = _ref2.getDatumStyles,\n      defaultColors = _ref2.defaultColors;\n  var defaults = {\n    // Pass some sane defaults\n    color: defaultColors[series.index % (defaultColors.length - 1)]\n  };\n\n  series.getStatusStyle = function (status) {\n    series.style = _Utils2.default.getStatusStyle(series, status, getStyles, defaults);\n    return series.style;\n  }; // We also need to decorate each datum in the same fashion\n\n\n  series.datums.forEach(function (datum) {\n    datum.getStatusStyle = function (status) {\n      datum.style = _Utils2.default.getStatusStyle(datum, status, getDatumStyles, defaults);\n      return datum.style;\n    };\n  });\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.state = {};\n\n  this.updatePath = function (props) {\n    var curve = props.curve,\n        series = props.series;\n    var lineFn = (0, _d3Shape.line)().x(function (d) {\n      return d.x;\n    }).y(function (d) {\n      return d.y;\n    }).defined(function (d) {\n      return d.defined;\n    }).curve(_Curves2.default[curve] || curve);\n\n    _this3.setState({\n      path: lineFn(series.datums)\n    });\n  };\n};\n\nexports.default = (0, _Context.ChartConnect)(function (state) {\n  return {\n    hovered: state.hovered,\n    selected: state.selected,\n    interaction: state.interaction\n  };\n})(Line);","map":null,"metadata":{},"sourceType":"script"}