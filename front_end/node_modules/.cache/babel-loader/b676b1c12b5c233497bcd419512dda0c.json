{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Context = require('../utils/Context');\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Selectors = require('../utils/Selectors');\n\nvar _Selectors2 = _interopRequireDefault(_Selectors);\n\nvar _interactionMethods = require('../utils/interactionMethods');\n\nvar _Rectangle = require('../primitives/Rectangle');\n\nvar _Rectangle2 = _interopRequireDefault(_Rectangle);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n\n\nvar Bar = function (_React$PureComponent) {\n  _inherits(Bar, _React$PureComponent);\n\n  function Bar(props) {\n    _classCallCheck(this, Bar);\n\n    var _this = _possibleConstructorReturn(this, (Bar.__proto__ || Object.getPrototypeOf(Bar)).call(this, props));\n\n    if (!props.interaction) {\n      _this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          interaction: 'element'\n        });\n      });\n    }\n\n    if (!props.hoverMode) {\n      _this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          hoverMode: 'primary'\n        });\n      });\n    }\n\n    _this.selectSeries = _interactionMethods.selectSeries.bind(_this);\n    _this.hoverSeries = _interactionMethods.hoverSeries.bind(_this);\n    _this.selectDatum = _interactionMethods.selectDatum.bind(_this);\n    _this.hoverDatum = _interactionMethods.hoverDatum.bind(_this);\n    return _this;\n  }\n\n  _createClass(Bar, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          series = _props.series,\n          visibility = _props.visibility,\n          primaryAxes = _props.primaryAxes,\n          selected = _props.selected,\n          hovered = _props.hovered,\n          interaction = _props.interaction;\n      var style = series.getStatusStyle(_Utils2.default.getStatus(series, hovered, selected));\n\n      var _ref = series.primaryAxisID ? primaryAxes.find(function (d) {\n        return d.id === series.primaryAxisID;\n      }) : primaryAxes[0],\n          barOffset = _ref.barOffset;\n\n      var interactiveSeries = interaction === 'series';\n      var seriesInteractionProps = interactiveSeries ? {\n        onClick: function onClick() {\n          return _this2.selectSeries(series);\n        },\n        onMouseEnter: function onMouseEnter() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseMove: function onMouseMove() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.hoverSeries(null);\n        }\n      } : {};\n      return _react2.default.createElement('g', {\n        className: 'series bar'\n      }, series.datums.map(function (datum, i) {\n        var x = datum ? datum.x : 0;\n        var y = datum ? datum.y : 0;\n        var base = datum ? datum.base : 0;\n        var size = datum ? datum.size : 0;\n        var x1 = void 0;\n        var y1 = void 0;\n        var x2 = void 0;\n        var y2 = void 0;\n\n        if (primaryAxes.find(function (d) {\n          return d.vertical;\n        })) {\n          x1 = base;\n          x2 = x;\n          y1 = y + barOffset;\n          y2 = y1 + size;\n        } else {\n          x1 = x + barOffset;\n          x2 = x1 + size;\n          y1 = y;\n          y2 = base;\n        }\n\n        var dataStyle = datum.getStatusStyle(_Utils2.default.getStatus(datum, hovered, selected));\n        var interactiveDatum = interaction === 'element';\n        var datumInteractionProps = interactiveDatum ? {\n          onClick: function onClick() {\n            return _this2.selectDatum(datum);\n          },\n          onMouseEnter: function onMouseEnter() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseMove: function onMouseMove() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseLeave: function onMouseLeave() {\n            return _this2.hoverDatum(null);\n          }\n        } : {};\n        return _react2.default.createElement(_Rectangle2.default, _extends({\n          style: _extends({}, style, style.rectangle, dataStyle, dataStyle.rectangle, {\n            pointerEvents: interactiveSeries || interactiveDatum ? 'all' : 'none'\n          }),\n          key: i,\n          x1: Number.isNaN(x1) ? null : x1,\n          y1: Number.isNaN(y1) ? null : y1,\n          x2: Number.isNaN(x2) ? null : x2,\n          y2: Number.isNaN(y2) ? null : y2,\n          opacity: visibility\n        }, seriesInteractionProps, datumInteractionProps));\n      }));\n    }\n  }]);\n\n  return Bar;\n}(_react2.default.PureComponent);\n\nBar.isBar = true;\n\nBar.plotDatum = function (datum, _ref2) {\n  var xAxis = _ref2.xAxis,\n      yAxis = _ref2.yAxis,\n      primaryAxis = _ref2.primaryAxis,\n      secondaryAxis = _ref2.secondaryAxis;\n  datum.x = xAxis.scale(datum.xValue);\n  datum.y = yAxis.scale(datum.yValue);\n  datum.defined = _Utils2.default.isValidPoint(datum.xValue) && _Utils2.default.isValidPoint(datum.yValue);\n  datum.base = secondaryAxis.scale(datum.baseValue);\n  datum.size = primaryAxis.barSize;\n\n  if (!secondaryAxis.stacked) {\n    datum.size = primaryAxis.seriesBarSize; // Use the seriesTypeIndex here in case we have mixed types.\n\n    var seriesBandScaleOffset = primaryAxis.seriesBandScale(datum.seriesTypeIndex);\n\n    if (secondaryAxis.vertical) {\n      datum.x += seriesBandScaleOffset;\n    } else {\n      datum.y += seriesBandScaleOffset;\n    }\n  } // Set the default focus point\n\n\n  datum.focus = {\n    x: datum.x,\n    y: datum.y,\n    horizontalPadding: secondaryAxis.vertical ? datum.size / 2 : 0,\n    verticalPadding: secondaryAxis.vertical ? 0 : datum.size / 2 // Adjust the focus point for bars\n\n  };\n\n  if (!primaryAxis.vertical) {\n    datum.focus.x += primaryAxis.type !== 'ordinal' ? 0 : datum.size / 2;\n  } else {\n    datum.focus.y += primaryAxis.type !== 'ordinal' ? 0 : datum.size / 2;\n  } // Set the pointer points (used in voronoi)\n\n\n  datum.pointerPoints = [// End of bar\n  datum.focus, // Start of bar\n  {\n    x: primaryAxis.vertical ? primaryAxis.position === 'left' ? datum.base - 1 : datum.base : datum.focus.x,\n    y: !primaryAxis.vertical ? primaryAxis.position === 'bottom' ? datum.base - 1 : datum.base : datum.focus.y\n  }];\n};\n\nBar.buildStyles = function (series, _ref3) {\n  var getStyles = _ref3.getStyles,\n      getDatumStyles = _ref3.getDatumStyles,\n      defaultColors = _ref3.defaultColors;\n  var defaults = {\n    // Pass some sane defaults\n    color: defaultColors[series.index % (defaultColors.length - 1)]\n  };\n\n  series.getStatusStyle = function (status) {\n    series.style = _Utils2.default.getStatusStyle(series, status, getStyles, defaults);\n    return series.style;\n  }; // We also need to decorate each datum in the same fashion\n\n\n  series.datums.forEach(function (datum) {\n    datum.getStatusStyle = function (status) {\n      datum.style = _Utils2.default.getStatusStyle(datum, status, getDatumStyles, defaults);\n      return datum.style;\n    };\n  });\n};\n\nexports.default = (0, _Context.ChartConnect)(function () {\n  var selectors = {\n    primaryAxes: _Selectors2.default.primaryAxes()\n  };\n  return function (state) {\n    return {\n      primaryAxes: selectors.primaryAxes(state),\n      hovered: state.hovered,\n      selected: state.selected,\n      interaction: state.interaction\n    };\n  };\n})(Bar);","map":null,"metadata":{},"sourceType":"script"}