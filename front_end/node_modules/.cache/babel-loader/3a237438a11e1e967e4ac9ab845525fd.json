{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _d3Shape = require('d3-shape');\n\nvar _Context = require('../utils/Context');\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Curves = require('../utils/Curves');\n\nvar _Curves2 = _interopRequireDefault(_Curves);\n\nvar _interactionMethods = require('../utils/interactionMethods');\n\nvar _Path = require('../primitives/Path');\n\nvar _Path2 = _interopRequireDefault(_Path);\n\nvar _Line = require('../primitives/Line');\n\nvar _Line2 = _interopRequireDefault(_Line);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n\n\nvar lineDefaultStyle = {\n  strokeWidth: 3\n};\n\nvar Area = function (_React$PureComponent) {\n  _inherits(Area, _React$PureComponent);\n\n  function Area(props) {\n    _classCallCheck(this, Area);\n\n    var _this = _possibleConstructorReturn(this, (Area.__proto__ || Object.getPrototypeOf(Area)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    if (!props.hoverMode) {\n      _this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          hoverMode: 'primary'\n        });\n      });\n    }\n\n    _this.selectSeries = _interactionMethods.selectSeries.bind(_this);\n    _this.hoverSeries = _interactionMethods.hoverSeries.bind(_this);\n    _this.selectDatum = _interactionMethods.selectDatum.bind(_this);\n    _this.hoverDatum = _interactionMethods.hoverDatum.bind(_this);\n    return _this;\n  }\n\n  _createClass(Area, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.updatePath(this.props);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.updatePath(this.props);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          series = _props.series,\n          visibility = _props.visibility,\n          showOrphans = _props.showOrphans,\n          selected = _props.selected,\n          hovered = _props.hovered,\n          interaction = _props.interaction;\n      var _state = this.state,\n          areaPath = _state.areaPath,\n          linePath = _state.linePath;\n\n      var status = _Utils2.default.getStatus(series, hovered, selected);\n\n      var style = series.getStatusStyle(status);\n      var interactiveSeries = interaction === 'series';\n      var seriesInteractionProps = interactiveSeries ? {\n        onClick: function onClick() {\n          return _this2.selectSeries(series);\n        },\n        onMouseEnter: function onMouseEnter() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseMove: function onMouseMove() {\n          return _this2.hoverSeries(series);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this2.hoverSeries(null);\n        }\n      } : {};\n      return _react2.default.createElement('g', null, _react2.default.createElement(_Path2.default, _extends({\n        d: areaPath,\n        style: _extends({}, style, style.area, {\n          stroke: 'transparent',\n          pointerEvents: interactiveSeries ? 'all' : 'none'\n        }),\n        opacity: visibility\n      }, seriesInteractionProps)), _react2.default.createElement(_Path2.default, _extends({\n        d: linePath,\n        style: _extends({}, style, style.line, {\n          fill: 'none',\n          pointerEvents: interactiveSeries ? 'all' : 'none'\n        }),\n        opacity: visibility\n      }, seriesInteractionProps)), series.datums.map(function (datum, i, all) {\n        // Don't render points on the line, just null data orphans\n        var prev = all[i - 1] || {\n          defined: true\n        };\n        var next = all[i + 1] || {\n          defined: true\n        };\n\n        if (!datum.defined || prev.defined && next.defined) {\n          return null;\n        }\n\n        var dataStyle = datum.getStatusStyle(_Utils2.default.getStatus(datum, hovered, selected));\n\n        if (!showOrphans) {\n          return null;\n        }\n\n        var interactiveDatum = interaction === 'element';\n        var datumInteractionProps = interactiveDatum ? {\n          onClick: function onClick() {\n            return _this2.selectDatum(datum);\n          },\n          onMouseEnter: function onMouseEnter() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseMove: function onMouseMove() {\n            return _this2.hoverDatum(datum);\n          },\n          onMouseLeave: function onMouseLeave() {\n            return _this2.hoverDatum(null);\n          }\n        } : {};\n        return _react2.default.createElement(_Line2.default, _extends({\n          style: _extends({}, lineDefaultStyle, style, style.line, dataStyle, dataStyle.line, {\n            pointerEvents: interactiveSeries ? 'all' : 'none'\n          }),\n          key: i,\n          x1: !datum || Number.isNaN(datum.x) ? null : datum.x,\n          y1: !datum || Number.isNaN(datum.base) ? null : datum.base,\n          x2: !datum || Number.isNaN(datum.x) ? null : datum.x,\n          y2: !datum || Number.isNaN(datum.y) ? null : datum.y,\n          opacity: visibility\n        }, seriesInteractionProps, datumInteractionProps));\n      }));\n    }\n  }]);\n\n  return Area;\n}(_react2.default.PureComponent);\n\nArea.defaultProps = {\n  showOrphans: true,\n  curve: 'monotoneX'\n};\n\nArea.plotDatum = function (datum, _ref) {\n  var primaryAxis = _ref.primaryAxis,\n      xAxis = _ref.xAxis,\n      yAxis = _ref.yAxis;\n  datum.x = xAxis.scale(datum.xValue);\n  datum.y = yAxis.scale(datum.yValue);\n  datum.defined = _Utils2.default.isValidPoint(datum.xValue) && _Utils2.default.isValidPoint(datum.yValue);\n  datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Adjust non-bar elements for ordinal scales\n\n  if (xAxis.type === 'ordinal') {\n    datum.x += xAxis.tickOffset;\n  }\n\n  if (yAxis.type === 'ordinal') {\n    datum.y += yAxis.tickOffset;\n  } // Set the default focus point\n\n\n  datum.focus = {\n    x: datum.x,\n    y: datum.y // Set the pointer points (used in voronoi)\n\n  };\n  datum.pointerPoints = [datum.focus, {\n    x: primaryAxis.vertical ? primaryAxis.position === 'left' ? datum.base - 1 : datum.base : datum.focus.x,\n    y: !primaryAxis.vertical ? primaryAxis.position === 'bottom' ? datum.base - 1 : datum.base : datum.focus.y\n  }];\n};\n\nArea.buildStyles = function (series, _ref2) {\n  var getStyles = _ref2.getStyles,\n      getDatumStyles = _ref2.getDatumStyles,\n      defaultColors = _ref2.defaultColors;\n  var defaults = {\n    // Pass some sane defaults\n    color: defaultColors[series.index % (defaultColors.length - 1)]\n  };\n\n  series.getStatusStyle = function (status) {\n    series.style = _Utils2.default.getStatusStyle(series, status, getStyles, defaults);\n    return series.style;\n  }; // We also need to decorate each datum in the same fashion\n\n\n  series.datums.forEach(function (datum) {\n    datum.getStatusStyle = function (status) {\n      datum.style = _Utils2.default.getStatusStyle(datum, status, getDatumStyles, defaults);\n      return datum.style;\n    };\n  });\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.state = {};\n\n  this.updatePath = function (props) {\n    var curve = props.curve,\n        series = props.series;\n    var areaFn = (0, _d3Shape.area)().x(function (d) {\n      return d.x;\n    }).y0(function (d) {\n      return d.base;\n    }).y1(function (d) {\n      return d.y;\n    }).defined(function (d) {\n      return d.defined;\n    }).curve(_Curves2.default[curve] || curve);\n    var lineFn = (0, _d3Shape.line)().x(function (d) {\n      return d.x;\n    }).y(function (d) {\n      return d.y;\n    }).defined(function (d) {\n      return d.defined;\n    }).curve(_Curves2.default[curve] || curve);\n\n    _this3.setState({\n      areaPath: areaFn(series.datums),\n      linePath: lineFn(series.datums)\n    });\n  };\n};\n\nexports.default = (0, _Context.ChartConnect)(function (state) {\n  return {\n    hovered: state.hovered,\n    selected: state.selected,\n    interaction: state.interaction\n  };\n})(Area);","map":null,"metadata":{},"sourceType":"script"}