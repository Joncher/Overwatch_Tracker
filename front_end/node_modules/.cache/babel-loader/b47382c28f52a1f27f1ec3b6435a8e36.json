{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = updateScale;\n\nvar _d3Shape = require('d3-shape');\n\nfunction updateScale(props) {\n  var type = props.type,\n      id = props.id,\n      materializedData = props.materializedData,\n      cutoutPercentage = props.cutoutPercentage,\n      width = props.width,\n      height = props.height,\n      dispatch = props.dispatch,\n      outerPadding = props.outerPadding,\n      cornerRadius = props.cornerRadius,\n      arcPadding = props.arcPadding,\n      seriesPadding = props.seriesPadding; // We need the data to proceed\n\n  if (!materializedData) {\n    return;\n  }\n\n  var midX = width / 2;\n  var midY = height / 2;\n  var radius = Math.max(Math.min(midX, midY) - outerPadding, 0);\n  var outerRadius = radius;\n  var innerRadius = radius * cutoutPercentage;\n  var totalRadius = outerRadius - innerRadius;\n  var seriesRadius = totalRadius / materializedData.length;\n  var padRadius = outerRadius * arcPadding * 20;\n  var seriesPaddingRadius = totalRadius * seriesPadding / 2.5;\n  var padAngle = 0.01;\n  var data = materializedData.map(function (series) {\n    var seriesInnerRadius = innerRadius + seriesRadius * series.index;\n    var seriesOuterRadius = seriesRadius + seriesInnerRadius;\n    var pie = (0, _d3Shape.pie)().sort(null).padAngle(padAngle).value(function (d) {\n      return d.secondary;\n    });\n    var pieData = pie(series.datums);\n    return pieData.map(function (d) {\n      var arcData = {\n        startAngle: d.startAngle,\n        endAngle: d.endAngle,\n        padAngle: d.padAngle,\n        padRadius: padRadius,\n        innerRadius: seriesInnerRadius + seriesPaddingRadius,\n        outerRadius: seriesOuterRadius,\n        cornerRadius: cornerRadius,\n        seriesPaddingRadius: seriesPaddingRadius // Calculate the arc for the centroid\n\n      };\n      var arc = (0, _d3Shape.arc)().startAngle(arcData.startAngle).endAngle(arcData.endAngle).padAngle(arcData.padAngle).padRadius(arcData.padRadius).innerRadius(arcData.innerRadius).outerRadius(arcData.outerRadius).cornerRadius(arcData.cornerRadius);\n      var centroid = arc.centroid();\n      return {\n        arcData: arcData,\n        arc: arc,\n        x: centroid[0] + midX,\n        y: centroid[1] + midY\n      };\n    });\n  });\n\n  var primaryScale = function primaryScale(d) {\n    return data[d.seriesIndex] ? data[d.seriesIndex][d.index] ? data[d.seriesIndex][d.index] : 0 : 0;\n  };\n\n  var secondaryScale = function secondaryScale() {};\n\n  primaryScale.range = function () {\n    return [0, width];\n  };\n\n  secondaryScale.range = function () {\n    return [height, 0];\n  };\n\n  var primaryAxis = {\n    id: id,\n    scale: primaryScale,\n    cutoutPercentage: cutoutPercentage,\n    type: type,\n    primary: true,\n    format: function format(d) {\n      return d;\n    },\n    width: width,\n    height: height,\n    radius: radius,\n    cornerRadius: cornerRadius,\n    arcPadding: arcPadding,\n    seriesPadding: seriesPadding,\n    outerRadius: outerRadius,\n    innerRadius: innerRadius,\n    totalRadius: totalRadius,\n    seriesRadius: seriesRadius,\n    padRadius: padRadius,\n    seriesPaddingRadius: seriesPaddingRadius,\n    padAngle: padAngle\n  };\n  var secondaryAxis = {\n    id: id,\n    scale: secondaryScale,\n    format: function format(d) {\n      return d;\n    },\n    type: type\n  };\n  dispatch(function (state) {\n    return _extends({}, state, {\n      axes: {\n        pie_primary: primaryAxis,\n        pie_secondary: secondaryAxis\n      }\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}