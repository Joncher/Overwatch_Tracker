{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = measure;\n\nvar _AxisLinear = require('./AxisLinear');\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar fontSize = 10;\n\nvar getPixel = function getPixel(d) {\n  return d;\n};\n\nvar radiansToDegrees = function radiansToDegrees(r) {\n  return r * (180 / Math.PI);\n};\n\nfunction measure() {\n  // Measure finds the amount of overflow this axis produces and\n  // updates the margins to ensure that the axis is visibility\n  // Unfortunately, this currently happens after a render, but potentially\n  // could happen pre-render if we could reliably predict the size of the\n  // labels before they render. Considering that ticks could be anything,\n  // even a react component, this could get very tough.\n  var _props = this.props,\n      axis = _props.axis,\n      tickSizeInner = _props.tickSizeInner,\n      tickSizeOuter = _props.tickSizeOuter,\n      tickPadding = _props.tickPadding,\n      maxLabelRotation = _props.maxLabelRotation,\n      position = _props.position,\n      dispatch = _props.dispatch,\n      id = _props.id;\n  var rotation = this.state.rotation;\n  var visibleLabelStep = this.visibleLabelStep;\n  var resolvedRotation = rotation;\n\n  if (!this.el) {\n    // If the entire axis is hidden, then we need to remove the axis dimensions\n    dispatch(function (state) {\n      var newAxes = state.axisDimensions[position] || {};\n      delete newAxes[id];\n      return _extends({}, state, {\n        axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, newAxes))\n      });\n    });\n    return;\n  }\n\n  var isHorizontal = position === _AxisLinear.positionTop || position === _AxisLinear.positionBottom;\n  var labelDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick text'))).map(function (el) {\n    return _extends({}, el.getBoundingClientRect().toJSON());\n  });\n  var smallestTickGap = 100000; // This is just a ridiculously large tick spacing that would never happen (hopefully)\n  // If the axis is horizontal, we need to determine any necessary rotation and tick skipping\n\n  if (isHorizontal) {\n    var tickDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick'))).map(function (el) {\n      return el.getBoundingClientRect();\n    }); // Determine the smallest gap in ticks on the axis\n\n    tickDims.reduce(function (prev, current) {\n      if (prev) {\n        var gap = current.left - prev.left;\n        smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;\n      }\n\n      return current;\n    }, false); // Determine the largest label on the axis\n\n    var largestLabel = labelDims.reduce(function (prev, current) {\n      current._overflow = current.width - smallestTickGap;\n\n      if (current._overflow > 0 && current._overflow > prev._overflow) {\n        return current;\n      }\n\n      return prev;\n    }, _extends({}, labelDims[0], {\n      _overflow: 0\n    })); // Determine axis rotation before we measure\n\n    var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos(smallestTickGap / (largestLabel.width + fontSize)))), 0), maxLabelRotation);\n    newRotation = Number.isNaN(newRotation) ? 0 : Math.round(newRotation);\n    resolvedRotation = newRotation;\n\n    if (Math.abs(rotation - newRotation) > 10) {\n      this.setState({\n        rotation: axis.position === 'top' ? -newRotation : newRotation\n      });\n    }\n  }\n\n  var newVisibleLabelStep = Math.ceil(fontSize / smallestTickGap);\n\n  if (visibleLabelStep !== newVisibleLabelStep) {\n    this.visibleLabelStep = newVisibleLabelStep;\n  }\n\n  if (!labelDims.length || labelDims.length !== this.ticks.length) {\n    return false;\n  }\n\n  var width = 0;\n  var height = 0;\n  var top = 0;\n  var bottom = 0;\n  var left = 0;\n  var right = 0;\n\n  if (isHorizontal) {\n    // Add width overflow from the first and last ticks\n    var leftWidth = getPixel(labelDims[0].width);\n    var rightWidth = getPixel(labelDims[labelDims.length - 1].width);\n\n    if (resolvedRotation) {\n      right = Math.ceil(fontSize / 2);\n      left = Math.abs(Math.ceil(Math.cos(resolvedRotation) * leftWidth)) - axis.barSize / 2;\n    } else {\n      left = Math.ceil(leftWidth / 2);\n      right = Math.ceil(rightWidth / 2);\n    }\n\n    height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size\n    tickPadding + // Add tick padding\n    // Add the height of the largest label\n    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {\n      return Math.ceil(getPixel(d.height));\n    })));\n  } else {\n    // Add height overflow from the first and last ticks\n    top = Math.ceil(getPixel(labelDims[0].height) / 2);\n    bottom = Math.ceil(getPixel(labelDims[labelDims.length - 1].height) / 2);\n    width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size\n    tickPadding + // Add tick padding\n    // Add the width of the largest label\n    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {\n      return Math.ceil(getPixel(d.width));\n    })));\n  }\n\n  var newDimensions = {\n    width: width,\n    height: height,\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right\n  };\n  dispatch(function (state) {\n    return _extends({}, state, {\n      axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, _extends({}, state.axisDimensions[position] || {}, _defineProperty({}, id, newDimensions))))\n    });\n  });\n  return true;\n}","map":null,"metadata":{},"sourceType":"script"}