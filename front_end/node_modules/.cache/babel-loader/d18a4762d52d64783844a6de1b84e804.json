{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Context = require('../utils/Context');\n\nvar _Utils = require('../utils/Utils');\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Selectors = require('../utils/Selectors');\n\nvar _Selectors2 = _interopRequireDefault(_Selectors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} //\n\n\nvar debug = process.env.NODE_ENV === 'development';\nvar defaultColors = ['#4ab5eb', '#fc6868', '#DECF3F', '#60BD68', '#FAA43A', '#c63b89', '#1aaabe', '#734fe9', '#1828bd', '#cd82ad'];\nvar modePrimary = 'primary';\nvar modeSecondary = 'secondary';\n\nvar getType = function getType(type, data, i) {\n  // Allow dynamic types\n  var typeGetter = typeof type === 'function' && type.prototype.isReactComponent ? function () {\n    return type;\n  } : type;\n  return typeGetter(data, i);\n};\n\nvar Series = function (_React$Component) {\n  _inherits(Series, _React$Component);\n\n  function Series() {\n    _classCallCheck(this, Series);\n\n    return _possibleConstructorReturn(this, (Series.__proto__ || Object.getPrototypeOf(Series)).apply(this, arguments));\n  }\n\n  _createClass(Series, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.updateMaterializedData(this.props);\n      this.updateStackData(this.props);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(oldProps) {\n      // If any of the following change,\n      // we need to update the materializedData\n      if (_Utils2.default.shallowCompare(oldProps, this.props, ['type', 'preMaterializedData'])) {\n        return this.updateMaterializedData(this.props);\n      } // If any of the following change,\n      // we need to update the stack\n\n\n      if (_Utils2.default.shallowCompare(oldProps, this.props, ['materializedData', 'axes', 'seriesKey', 'primaryAxes', 'secondaryAxes', 'groupMode'])) {\n        this.updateStackData(this.props);\n      }\n    }\n  }, {\n    key: 'updateMaterializedData',\n    value: function updateMaterializedData(props) {\n      var preMaterializedData = props.preMaterializedData,\n          type = props.type,\n          dispatch = props.dispatch; // We need preMaterializedData to proceed\n\n      if (!preMaterializedData) {\n        return;\n      }\n\n      dispatch(function (state) {\n        return _extends({}, state, {\n          materializedData: preMaterializedData.map(function (series, index) {\n            var SeriesComponent = getType(type, series, index);\n\n            if (debug && !SeriesComponent) {\n              console.error(series);\n              throw new Error('An invalid series component was passed for the series above (index: ' + index + '.');\n            }\n\n            return _extends({}, series, {\n              Component: SeriesComponent\n            });\n          }).map(function (series, i, all) {\n            var seriesTypeIndex = all.filter(function (d, j) {\n              return j < i && d.Component === series.Component;\n            }).length;\n            return _extends({}, series, {\n              seriesTypeIndex: seriesTypeIndex,\n              datums: series.datums.map(function (datum) {\n                return _extends({}, datum, {\n                  seriesTypeIndex: seriesTypeIndex\n                });\n              })\n            });\n          })\n        });\n      });\n    }\n  }, {\n    key: 'updateStackData',\n    value: function updateStackData(props) {\n      var _this2 = this;\n\n      var materializedData = props.materializedData,\n          primaryAxes = props.primaryAxes,\n          secondaryAxes = props.secondaryAxes,\n          groupMode = props.groupMode; // We need materializedData and both axes to continue\n\n      if (!materializedData || !primaryAxes.length || !secondaryAxes.length) {\n        return;\n      } // If the axes are ready, let's decorate the materializedData for visual plotting\n      // const secondaryStacked = secondaryAxes.stacked\n      // Make sure we're mapping x and y to the correct axes\n\n\n      var xKey = primaryAxes.find(function (d) {\n        return d.vertical;\n      }) ? 'secondary' : 'primary';\n      var yKey = primaryAxes.find(function (d) {\n        return d.vertical;\n      }) ? 'primary' : 'secondary';\n      var xAxes = primaryAxes.find(function (d) {\n        return d.vertical;\n      }) ? secondaryAxes : primaryAxes;\n      var yAxes = primaryAxes.find(function (d) {\n        return d.vertical;\n      }) ? primaryAxes : secondaryAxes; // \"totals\" are kept per secondaryAxis and used for bases if secondaryAxis stacking is enabled\n\n      var scaleTotals = secondaryAxes.map(function () {\n        return {};\n      });\n      materializedData.forEach(function (series) {\n        var axisIndex = _Utils2.default.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);\n\n        series.datums.forEach(function (datum) {\n          scaleTotals[axisIndex][datum.primary] = {\n            negative: 0,\n            positive: 0\n          };\n        });\n      }); // Determine the correct primary and secondary values for each axis\n      // Also calculate bases and totals if either axis is stacked\n\n      var stackData = materializedData.map(function (series) {\n        var primaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(primaryAxes, series.primaryAxisID);\n\n        var primaryAxis = primaryAxes[primaryAxisIndex];\n\n        var secondaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);\n\n        var secondaryAxis = secondaryAxes[secondaryAxisIndex];\n        return _extends({}, series, {\n          datums: series.datums.map(function (d) {\n            var datum = _extends({}, d, {\n              xValue: d[xKey],\n              yValue: d[yKey],\n              baseValue: 0\n            });\n\n            if (secondaryAxis.stacked) {\n              var start = scaleTotals[secondaryAxisIndex][d.primary]; // Stack the x or y values (according to axis positioning)\n\n              if (primaryAxis.vertical) {\n                // Is this a valid point?\n                var validPoint = _Utils2.default.isValidPoint(datum.xValue); // Should we use positive or negative base?\n\n\n                var totalKey = datum.xValue >= 0 ? 'positive' : 'negative'; // Assign the base\n\n                datum.baseValue = start[totalKey]; // Add the value for a total\n\n                datum.totalValue = datum.baseValue + (validPoint ? datum.xValue : 0); // Update the totals\n\n                scaleTotals[secondaryAxisIndex][d.primary][totalKey] = datum.totalValue; // Make the total the new value\n\n                datum.xValue = validPoint ? datum.totalValue : null;\n              } else {\n                // Is this a valid point?\n                var _validPoint = _Utils2.default.isValidPoint(datum.yValue); // Should we use positive or negative base?\n\n\n                var _totalKey = datum.yValue >= 0 ? 'positive' : 'negative'; // Assign the base\n\n\n                datum.baseValue = start[_totalKey]; // Add the value to the base\n\n                datum.totalValue = datum.baseValue + (_validPoint ? datum.yValue : 0); // Update the totals\n\n                scaleTotals[secondaryAxisIndex][d.primary][_totalKey] = datum.totalValue; // Make the total the new value\n\n                datum.yValue = _validPoint ? datum.totalValue : null;\n              }\n            }\n\n            return datum;\n          })\n        });\n      });\n      stackData.forEach(function (series) {\n        series.datums.forEach(function (datum) {\n          datum.series = series;\n        });\n      }); // Use the plotDatum method on each series\n\n      stackData.forEach(function (series, i) {\n        if (debug && !series.Component.plotDatum) {\n          throw new Error('Could not find a [SeriesType].plotDatum() static method for the series Component above (index: ' + i + ')');\n        }\n\n        var primaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(primaryAxes, series.primaryAxisID);\n\n        var primaryAxis = primaryAxes[primaryAxisIndex];\n\n        var secondaryAxisIndex = _Utils2.default.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);\n\n        var secondaryAxis = secondaryAxes[secondaryAxisIndex];\n\n        var xAxisIndex = _Utils2.default.getAxisIndexByAxisID(xAxes, series[xKey + 'AxisID']);\n\n        var xAxis = xAxes[xAxisIndex];\n\n        var yAxisIndex = _Utils2.default.getAxisIndexByAxisID(yAxes, series[yKey + 'AxisID']);\n\n        var yAxis = yAxes[yAxisIndex];\n        series.datums = series.datums.map(function (d) {\n          // Data for cartesian charts\n          var result = series.Component.plotDatum(d, {\n            primaryAxis: primaryAxis,\n            secondaryAxis: secondaryAxis,\n            xAxis: xAxis,\n            yAxis: yAxis\n          });\n          return result || d;\n        });\n      }); // Do any data grouping ahead of time\n\n      if ([modePrimary, modeSecondary].includes(groupMode)) {\n        var datumsByGrouping = {};\n        stackData.forEach(function (series) {\n          series.datums.filter(function (d) {\n            return d.defined;\n          }).forEach(function (datum) {\n            var axisKey = String(groupMode === modePrimary ? datum.primary : datum.secondary);\n            datumsByGrouping[axisKey] = datumsByGrouping[axisKey] || [];\n            datumsByGrouping[axisKey].push(datum);\n          });\n        });\n        stackData.forEach(function (series) {\n          series.datums.forEach(function (datum) {\n            var axisKey = String(groupMode === modePrimary ? datum.primary : datum.secondary);\n            datum.group = datumsByGrouping[axisKey];\n          });\n        });\n      } // Not we need to precalculate all of the possible status styles by\n      // calling the seemingly 'live' getStyles, and getDatumStyles callbacks ;)\n\n\n      stackData = stackData.map(function (series, i) {\n        if (debug && !series.Component.buildStyles) {\n          throw new Error('Could not find a SeriesType.buildStyles() static method for the series Component above (index: ' + i + ')');\n        }\n\n        var result = series.Component.buildStyles(series, {\n          // Make sure we are using a thunk to get the most recent getStyles and getDatumStyles\n          getStyles: function getStyles() {\n            var _props;\n\n            return (_props = _this2.props).getStyles.apply(_props, arguments);\n          },\n          getDatumStyles: function getDatumStyles() {\n            var _props2;\n\n            return (_props2 = _this2.props).getDatumStyles.apply(_props2, arguments);\n          },\n          defaultColors: defaultColors\n        });\n        return result || series;\n      });\n      this.props.dispatch(function (state) {\n        return _extends({}, state, {\n          stackData: stackData\n        });\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          type = _props3.type,\n          getStyles = _props3.getStyles,\n          getDatumStyles = _props3.getDatumStyles,\n          stackData = _props3.stackData,\n          rest = _objectWithoutProperties(_props3, ['type', 'getStyles', 'getDatumStyles', 'stackData']);\n\n      if (!stackData) {\n        return null;\n      }\n\n      var reversedStackData = [].concat(_toConsumableArray(stackData)).reverse(); // For proper svg stacking\n\n      return _react2.default.createElement('g', {\n        className: 'Series'\n      }, reversedStackData.map(function (stack) {\n        var StackCmp = getType(type, stack, stack.id);\n        return _react2.default.createElement(StackCmp, _extends({}, rest, {\n          key: stack.id,\n          series: stack,\n          stackData: stackData\n        }));\n      }));\n    }\n  }]);\n\n  return Series;\n}(_react2.default.Component);\n\nSeries.defaultProps = {\n  getStyles: function getStyles() {\n    return {};\n  },\n  getDatumStyles: function getDatumStyles() {\n    return {};\n  }\n};\nexports.default = (0, _Context.ChartConnect)(function () {\n  var selectors = {\n    primaryAxes: _Selectors2.default.primaryAxes(),\n    secondaryAxes: _Selectors2.default.secondaryAxes()\n  };\n  return function (state) {\n    return {\n      primaryAxes: selectors.primaryAxes(state),\n      secondaryAxes: selectors.secondaryAxes(state),\n      preMaterializedData: state.preMaterializedData,\n      materializedData: state.materializedData,\n      stackData: state.stackData,\n      tooltip: state.tooltip,\n      hovered: state.hovered,\n      selected: state.selected,\n      groupMode: state.groupMode\n    };\n  };\n})(Series);","map":null,"metadata":{},"sourceType":"script"}