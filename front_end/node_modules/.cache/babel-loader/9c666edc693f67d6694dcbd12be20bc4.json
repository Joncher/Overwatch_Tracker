{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.default = updateScale;\n\nvar _d3Scale = require('d3-scale');\n\nvar _AxisLinear = require('./AxisLinear');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} //\n\n\nvar scales = {\n  linear: _d3Scale.scaleLinear,\n  log: _d3Scale.scaleLog,\n  time: _d3Scale.scaleTime,\n  utc: _d3Scale.scaleUtc,\n  ordinal: _d3Scale.scaleBand\n};\n\nvar detectVertical = function detectVertical(position) {\n  return [_AxisLinear.positionLeft, _AxisLinear.positionRight].indexOf(position) > -1;\n};\n\nvar detectRTL = function detectRTL(position) {\n  return [_AxisLinear.positionTop, _AxisLinear.positionRight].indexOf(position) > -1;\n};\n\nfunction updateScale(props) {\n  var _scale, _scale2;\n\n  var id = props.id,\n      type = props.type,\n      position = props.position,\n      invert = props.invert,\n      primary = props.primary,\n      stacked = props.stacked,\n      innerPadding = props.innerPadding,\n      outerPadding = props.outerPadding,\n      tickArguments = props.tickArguments,\n      tickValues = props.tickValues,\n      tickFormat = props.tickFormat,\n      tickPadding = props.tickPadding,\n      tickSizeInner = props.tickSizeInner,\n      base = props.base,\n      defaultMin = props.min,\n      defaultMax = props.max,\n      hardMin = props.hardMin,\n      hardMax = props.hardMax,\n      primaryAxisID = props.primaryAxisID,\n      materializedData = props.materializedData,\n      width = props.width,\n      height = props.height,\n      primaryAxes = props.primaryAxes; // We need the data to proceed\n\n  if (!materializedData) {\n    return;\n  } // If this axis is secondary, we need the primaryAxes to proceed\n\n\n  if (!primary && !primaryAxes.length) {\n    return;\n  } // Detect some settings\n\n\n  var valueKey = primary ? 'primary' : 'secondary';\n  var groupKey = !primary && 'primary';\n  var AxisIDKey = valueKey + 'AxisID';\n  var vertical = detectVertical(position);\n  var RTL = detectRTL(position); // Right to left OR top to bottom\n  // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly\n  // First we need to find unique values, min/max values and negative/positive totals\n\n  var uniqueVals = [];\n  var min = void 0;\n  var max = void 0;\n  var datumValues = {};\n  var negativeTotal = 0;\n  var positiveTotal = 0;\n  var domain = void 0;\n\n  if (type === 'ordinal') {\n    materializedData.forEach(function (series) {\n      if (series[AxisIDKey] && series[AxisIDKey] !== id) {\n        return;\n      }\n\n      var seriesValues = series.datums.map(function (d) {\n        return d[valueKey];\n      });\n      seriesValues.forEach(function (d) {\n        if (uniqueVals.indexOf(d) === -1) {\n          uniqueVals.push(d);\n        }\n      });\n    });\n    domain = uniqueVals;\n  } else if (type === 'time' || type === 'utc') {\n    materializedData.forEach(function (series) {\n      if (series[AxisIDKey] && series[AxisIDKey] !== id) {\n        return;\n      }\n\n      var seriesValues = series.datums.map(function (d) {\n        return +d[valueKey];\n      });\n      seriesValues.forEach(function (d, i) {\n        var key = groupKey ? series.datums[i][groupKey] : i;\n        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);\n      });\n      min = Math.min.apply(Math, _toConsumableArray(typeof min !== 'undefined' ? [min] : []).concat(_toConsumableArray(seriesValues)));\n      max = Math.max.apply(Math, _toConsumableArray(typeof max !== 'undefined' ? [max] : []).concat(_toConsumableArray(seriesValues)));\n    });\n    domain = [min, max];\n  } else {\n    // Linear scale\n    materializedData.forEach(function (series) {\n      if (series[AxisIDKey] && series[AxisIDKey] !== id) {\n        return;\n      }\n\n      var seriesValues = series.datums.map(function (d) {\n        return d[valueKey];\n      });\n      seriesValues.forEach(function (d, i) {\n        var key = groupKey ? series.datums[i][groupKey] : i;\n        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);\n      });\n      seriesValues = seriesValues.filter(function (d) {\n        return typeof d === 'number';\n      });\n      min = Math.min.apply(Math, _toConsumableArray(typeof min === 'number' ? [min] : []).concat(_toConsumableArray(seriesValues)));\n      max = Math.max.apply(Math, _toConsumableArray(typeof max === 'number' ? [max] : []).concat(_toConsumableArray(seriesValues)));\n    });\n\n    if (stacked) {\n      var _Object$keys$map$redu = Object.keys(datumValues).map(function (d) {\n        return datumValues[d];\n      }).reduce(function (totals, vals) {\n        var positive = vals.filter(function (d) {\n          return d >= 0;\n        }).reduce(function (ds, d) {\n          return ds + d;\n        }, 0);\n        var negative = vals.filter(function (d) {\n          return d < 0;\n        }).reduce(function (ds, d) {\n          return ds + d;\n        }, 0);\n        return [positive > totals[0] ? positive : totals[0], negative < totals[1] ? negative : totals[1]];\n      }, [0, 0]); // If we're stacking, calculate and use the max and min values for the largest stack\n\n\n      var _Object$keys$map$redu2 = _slicedToArray(_Object$keys$map$redu, 2);\n\n      positiveTotal = _Object$keys$map$redu2[0];\n      negativeTotal = _Object$keys$map$redu2[1];\n      domain = [negativeTotal, positiveTotal];\n    } else {\n      // If we're not stacking, use the min and max values\n      domain = [min, max];\n    }\n  } // Now we need to figure out the range\n\n\n  var range = vertical ? [height, 0] // If the axis is inverted, swap the range, too\n  : [0, width];\n\n  if (!primary) {\n    // Secondary axes are usually dependent on primary axes for orientation, so if the\n    // primaryAxis is in RTL mode, we need to reverse the range on this secondary axis\n    // to match the origin of the primary axis\n    var primaryAxis = primaryAxisID ? primaryAxes[primaryAxisID] : primaryAxes[0];\n\n    if (primaryAxis.RTL) {\n      range = [].concat(_toConsumableArray(range)).reverse();\n    }\n  } // Give the scale a home\n\n\n  var scale = void 0; // If this is an ordinal or other primary axis, it needs to be able to display bars.\n\n  var bandScale = void 0;\n  var barSize = 0;\n  var cursorSize = 0;\n  var stepSize = 0;\n\n  var seriesBandScale = function seriesBandScale(d) {\n    return d;\n  };\n\n  var seriesBarSize = 1;\n\n  if (type === 'ordinal' || primary) {\n    // Calculate a band axis that is similar and pass down the bandwidth\n    // just in case.\n    bandScale = (0, _d3Scale.scaleBand)().domain(materializedData.reduce(function (prev, current) {\n      return current.datums.length > prev.length ? current.datums : prev;\n    }, []).map(function (d) {\n      return d.primary;\n    })).rangeRound(range, 0.1).padding(0);\n    bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);\n    barSize = bandScale.bandwidth();\n\n    if (type === 'ordinal') {\n      cursorSize = barSize;\n    } // barSize = bandScale.bandwidth()\n\n\n    stepSize = bandScale.step(); // Create a seriesBandScale in case this axis isn't stacked\n\n    seriesBandScale = (0, _d3Scale.scaleBand)().paddingInner(innerPadding / 2).domain(materializedData.filter(function (d) {\n      return d.Component.isBar;\n    }).map(function (d, i) {\n      return i;\n    })).rangeRound([0, barSize]);\n    seriesBarSize = seriesBandScale.bandwidth();\n  }\n\n  if (type === 'ordinal') {\n    // If it's ordinal, just assign the bandScale we made\n    scale = bandScale;\n  } else {\n    // Otherwise, create a new scale of the appropriate type\n    scale = scales[type]();\n  } // Set base, min, and max\n\n\n  if (typeof base === 'number') {\n    domain[0] = Math.min(domain[0], base);\n    domain[1] = Math.max(domain[1], base);\n  }\n\n  if (typeof defaultMin === 'number') {\n    domain[0] = Math.min(domain[0], defaultMin);\n  }\n\n  if (typeof defaultMax === 'number') {\n    domain[1] = Math.max(domain[1], defaultMax);\n  } // Set the domain\n\n\n  scale.domain(domain); // If we're not using an ordinal scale, round the ticks to \"nice\" values\n\n  if (type !== 'ordinal') {\n    scale.nice();\n  } // If hard min and max are set, override any \"nice\" rounding values\n\n\n  if (typeof hardMin === 'number') {\n    scale.domain([hardMin, scale.domain()[1]]);\n  }\n\n  if (typeof hardMax === 'number') {\n    scale.domain([scale.domain()[0], hardMax]);\n  } // Invert if necessary\n\n\n  if (invert) {\n    scale.domain([].concat(_toConsumableArray(scale.domain())).reverse());\n  } // Now set the range\n\n\n  scale.range(range); // Pass down the axis config (including the scale itself) for posterity\n\n  var axis = {\n    id: id,\n    type: type,\n    scale: scale,\n    uniqueVals: uniqueVals,\n    primary: primary,\n    invert: invert,\n    vertical: vertical,\n    RTL: RTL,\n    position: position,\n    stacked: stacked,\n    barSize: barSize,\n    cursorSize: cursorSize,\n    stepSize: stepSize,\n    seriesBandScale: seriesBandScale,\n    seriesBarSize: seriesBarSize,\n    domain: domain,\n    range: range,\n    max: position === _AxisLinear.positionBottom ? -height : position === _AxisLinear.positionLeft ? width : position === _AxisLinear.positionTop ? height : -width,\n    directionMultiplier: position === _AxisLinear.positionTop || position === _AxisLinear.positionLeft ? -1 : 1,\n    transform: !vertical ? translateX : translateY,\n    ticks: this.ticks = !tickValues ? scale.ticks ? (_scale = scale).ticks.apply(_scale, _toConsumableArray(tickArguments)) : scale.domain() : tickValues,\n    format: !tickFormat ? scale.tickFormat ? (_scale2 = scale).tickFormat.apply(_scale2, _toConsumableArray(tickArguments)) : identity : tickFormat,\n    spacing: Math.max(tickSizeInner, 0) + tickPadding\n  };\n\n  if (type === 'ordinal') {\n    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;\n    axis.tickOffset = axis.barSize / 2;\n    axis.barOffset = 0;\n  } else {\n    axis.tickOffset = 0;\n    axis.barOffset = -axis.barSize / 2;\n  } // Make sure we start with a prevAxis\n\n\n  this.prevAxis = this.prevAxis || axis;\n  this.props.dispatch(function (state) {\n    return _extends({}, state, {\n      axes: _extends({}, state.axes, _defineProperty({}, id, axis))\n    });\n  });\n}\n\nfunction identity(x) {\n  return x;\n}\n\nfunction translateX(x) {\n  return 'translate3d(' + x + 'px, 0, 0)';\n}\n\nfunction translateY(y) {\n  return 'translate3d(0, ' + y + 'px, 0)';\n}","map":null,"metadata":{},"sourceType":"script"}